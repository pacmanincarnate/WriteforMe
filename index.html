<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NovelCraft 2.4 - AI Story Architect</title>
    
    <!-- 1. Tailwind CSS (Styling) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM (Core Framework) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. Babel (JSX Compiler) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Lucide Icons (Visuals) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Custom Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&display=swap');
        
        body { background-color: #0f172a; color: #e2e8f0; font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Merriweather', serif; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #6366f1; cursor: pointer; margin-top: -6px; border: 2px solid #fff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }

        /* Typography & Utility */
        .prose p { margin-bottom: 1.5em; line-height: 1.8; }
        .prose strong { color: #f8fafc; font-weight: 700; }
        .prose em { color: #cbd5e1; font-style: italic; }
        
        .nav-btn {
            width: 100%; text-align: left; padding: 0.5rem 0.75rem; border-radius: 0.5rem;
            display: flex; align-items: center; gap: 0.75rem; font-size: 0.875rem;
            color: #94a3b8; transition: all 0.2s;
        }
        .nav-btn:hover { background-color: #1e293b; color: #f1f5f9; }
        .nav-btn.active { background-color: rgba(79, 70, 229, 0.15); color: #a5b4fc; border: 1px solid rgba(99, 102, 241, 0.3); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 1. API CONFIGURATION ---
        // REPLACE WITH YOUR GEMINI API KEY
        const apiKey = ""; 

        // --- 2. ICON SYSTEM SETUP ---
        // Helper to render Lucide icons in React without the full library build
        const Icon = ({ name, className, ...props }) => {
            React.useEffect(() => {
                lucide.createIcons();
            });
            return <i data-lucide={name} className={className} {...props}></i>;
        };

        // Map component names to Lucide icon names (kebab-case)
        const Book = (p) => <Icon name="book" {...p} />;
        const Layers = (p) => <Icon name="layers" {...p} />;
        const Film = (p) => <Icon name="film" {...p} />;
        const Feather = (p) => <Icon name="feather" {...p} />;
        const ChevronRight = (p) => <Icon name="chevron-right" {...p} />;
        const ChevronDown = (p) => <Icon name="chevron-down" {...p} />;
        const Sparkles = (p) => <Icon name="sparkles" {...p} />;
        const Save = (p) => <Icon name="save" {...p} />;
        const RefreshCw = (p) => <Icon name="refresh-cw" {...p} />;
        const Edit3 = (p) => <Icon name="edit-3" {...p} />;
        const ArrowLeft = (p) => <Icon name="arrow-left" {...p} />;
        const FileText = (p) => <Icon name="file-text" {...p} />;
        const Settings = (p) => <Icon name="settings" {...p} />;
        const AlertCircle = (p) => <Icon name="alert-circle" {...p} />;
        const Menu = (p) => <Icon name="menu" {...p} />;
        const X = (p) => <Icon name="x" {...p} />;
        const Users = (p) => <Icon name="users" {...p} />;
        const User = (p) => <Icon name="user" {...p} />;
        const Target = (p) => <Icon name="target" {...p} />;
        const Brain = (p) => <Icon name="brain" {...p} />;
        const Globe = (p) => <Icon name="globe" {...p} />;
        const PenTool = (p) => <Icon name="pen-tool" {...p} />;
        const GitBranch = (p) => <Icon name="git-branch" {...p} />;
        const MessageSquare = (p) => <Icon name="message-square" {...p} />;
        const Eye = (p) => <Icon name="eye" {...p} />;
        const Activity = (p) => <Icon name="activity" {...p} />;
        const CheckCircle2 = (p) => <Icon name="check-circle-2" {...p} />;
        const Sliders = (p) => <Icon name="sliders" {...p} />;
        const TrendingUp = (p) => <Icon name="trending-up" {...p} />;
        const TrendingDown = (p) => <Icon name="trending-down" {...p} />;
        const Minus = (p) => <Icon name="minus" {...p} />;
        const Volume2 = (p) => <Icon name="volume-2" {...p} />;
        const Copy = (p) => <Icon name="copy" {...p} />;
        const History = (p) => <Icon name="history" {...p} />;
        const Scroll = (p) => <Icon name="scroll" {...p} />;
        const Download = (p) => <Icon name="download" {...p} />;
        const Upload = (p) => <Icon name="upload" {...p} />;


        /* ----------------------------------------------------------------------
          UTILS: AUDIO & MARKDOWN
          ----------------------------------------------------------------------
        */

        const pcmToWav = (pcmData, sampleRate = 24000) => {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            const pcmBytes = new Uint8Array(pcmData);
            const wavBytes = new Uint8Array(buffer, 44);
            wavBytes.set(pcmBytes);
            return buffer;
        };

        const parseMarkdown = (text) => {
            if (!text) return "";
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br />');
            return `<p>${html}</p>`;
        };

        /* ----------------------------------------------------------------------
          GEMINI PROMPTS
          ----------------------------------------------------------------------
        */
        const PROMPTS = {
            storyArchitect: `You are a Lead Narrative Designer.
  Input: A concept.
  Task: Deconstruct this into a Story Bible.
  Requirements:
  - Create 3 distinct narrative threads (Main Plot, Subplot A, Subplot B).
  - Create a Protagonist with deep details:
    - History: Their backstory before the book.
    - Story Events: Initialize as "Story Start".
    - Goals: Abstract and concrete.
    - Evolution: How they SHOULD change by the end.
  
  Output JSON:
  {
    "concept": "Refined summary",
    "threads": [
      { "id": "t1", "name": "Main Arc", "description": "The primary conflict" },
      { "id": "t2", "name": "Relationship Arc", "description": "Interpersonal dynamics" }
    ],
    "protagonist": {
      "name": "Name",
      "role": "Protagonist",
      "description": "Physical/Personality",
      "core_need": "Internal unfulfilled desire",
      "voice_sample": "A representative sentence of dialogue.",
      "details": {
        "history": "Detailed backstory...",
        "story_events": "Current status: At the beginning.",
        "goals": "Current desires...",
        "evolution": "Planned character arc..."
      }
    },
    "world_lore": [
      { "topic": "Setting", "detail": "Key location detail" }
    ]
  }`,

  actStructure: `You are a Pacing Expert.
  Task: Break the story into exactly 3 Acts.
  Input: Concept, Threads.
  Output JSON:
  {
    "acts": [
      { "number": 1, "title": "The Departure", "description": "From Normal to the Unknown", "focus_thread_ids": ["t1"] },
      { "number": 2, "title": "The Initiation", "description": "Trials, Complexity, and Crisis", "focus_thread_ids": ["t1", "t2"] },
      { "number": 3, "title": "The Return", "description": "Resolution and New Normal", "focus_thread_ids": ["t1", "t2"] }
    ]
  }`,

  sceneWeaverAct1: `You are an Act 1 Architect.
  Task: Create scenes for ACT 1 (The Departure).
  
  PACING REQUIREMENT:
  - Generate between 12-16 scenes.
  - SCENES 1-3 MUST BE SETUP ONLY. Do not start the Inciting Incident yet. Establish the "Status Quo".
  - SCENE 4-5: The Inciting Incident (The disruption).
  - SCENES 6-12: The Debate & Preparation.
  - FINAL SCENE: The Crossing of the Threshold (Point of No Return).
  
  Include "World Building" scenes where plot is slow but atmosphere is high.
  Include "Character Bonding" scenes.
  
  *ROSTER CHECK*: If you introduce NEW major characters to fulfill these scenes, list them in "new_characters".
  
  Output JSON:
  {
    "scenes": [
      { "number": 1, "title": "Scene Title", "description": "Plot events", "active_thread_ids": ["t1"], "location": "Setting", "cast_names": ["Hero"], "valence": 0 }
    ],
    "new_characters": [ { "name": "...", "role": "...", "description": "...", "voice_sample": "...", "details": { "history": "...", "goals": "...", "evolution": "..." } } ]
  }`,

  sceneWeaverAct2: `You are an Act 2 Architect.
  Task: Create scenes for ACT 2 (The Confrontation).
  
  PACING REQUIREMENT:
  - Generate between 18-24 scenes. This is the main meat of the book.
  - FIRST HALF: Fun & Games / Training / Testing the waters.
  - MIDPOINT (Roughly Scene 10-12): A major realization or shift in power. Stakes raised.
  - SECOND HALF: The Bad Guys Close In. Failures cost more.
  - FINAL SCENE: Total Crisis (All Hope is Lost).
  
  Slow down the middle. Allow characters to fail small before failing big.
  Include "Campfire Scenes" where characters reflect on the journey.
  
  VALENCE: High oscillation. The end of the Act must have a strong NEGATIVE valence (-8 to -10) representing the crisis.
  *ROSTER CHECK*: If you introduce NEW major characters, list them in "new_characters".
  
  Output JSON:
  {
    "scenes": [ { "number": 1, "title": "Scene Title", "description": "...", "active_thread_ids": ["t1"], "location": "...", "cast_names": ["..."], "valence": -5 } ],
    "new_characters": []
  }`,

  sceneWeaverAct3: `You are an Act 3 Architect.
  Task: Create scenes for ACT 3 (The Resolution).
  
  PACING REQUIREMENT:
  - Generate 10-14 scenes.
  - SCENES 1-3: The Assessment/Dark Night. Characters pick up the pieces.
  - SCENES 4-5: The Plan. Formulating a desperate strategy.
  - SCENES 6-9: The Climax. Head-on conflict. The threads intersect.
  - FINAL SCENES: The Denouement (New Normal). Show how the world has changed. Reflect on the "Original Normal" from Act 1.
  
  VALENCE: Start low (from Act 2 crisis), rise to tension, end High Positive (Resolution).
  
  Output JSON:
  {
    "scenes": [ { "number": 1, "title": "Scene Title", "description": "...", "active_thread_ids": ["t1"], "location": "...", "cast_names": ["..."], "valence": 5 } ],
    "new_characters": []
  }`,

  beatDirector: `You are a Cinematic Director.
  Task: Break a scene into 6-10 distinct beats.
  Input: Scene context, Threads involved.
  Requirement: Vary the type of beats (Action, Reaction, Revelation).
  
  VALENCE: Assign a "valence" score (-10 to +10) to each beat. 
  Oscillate between positive and negative beats to maintain tension.
  
  Output JSON:
  {
    "beats": [
      { "number": 1, "type": "Action/Reaction/Dialogue", "description": "What happens", "emotional_shift": "How the mood changes", "valence": 4 }
    ]
  }`,

  drafter: `You are a Literary Draftsman.
  Task: Write the raw prose for a beat.
  Context: 
  - Subtext: {subtext}
  - Pacing: {pacing}
  - Cast Voices: {voices}
  - Lore: {lore}
  - Valence (Good/Bad outcome): {valence}
  
  Rule: Write 400-600 words. Focus on getting the details down. Don't worry about being too flowery yet. Focus on "Show, Don't Tell" where possible. Capture the emotional valence specified. Use bold for emphasis and italics for internal thought or emphasis where appropriate.
  Output: Plain Text (Markdown supported).`,

  editor: `You are a Ruthless Editor.
  Task: Polish the following draft.
  Rules:
  1. Cut exposition.
  2. Strengthen verbs.
  3. Ensure character voice matches the samples.
  4. Fix "filter words" (e.g., change "He saw the box" to "The box sat on the table").
  5. Preserve bold/italics for emphasis.
  
  Input Draft: {draft}
  Output: Plain Text (The Final Polish).`,

  archivist: `You are the Story Archivist.
  Task: Analyze the just-written text and return UPDATES for the Story Bible.
  
  Text Segment: {text}
  Current Cast: {cast_summary}
  
  1. CAST UPDATES: 
     - Did a character reveal new Backstory (History)?
     - Did a major Event just happen to them? (Add to Story Events)
     - Did their Goal change?
  2. LORE UPDATES:
     - Was a new location or object described in detail?
  
  Output JSON:
  {
    "cast_updates": [
      { "name": "Hero", "append_history": "...", "append_story_events": "...", "update_goals": "..." }
    ],
    "lore_updates": [
      { "topic": "...", "detail": "..." }
    ]
  }`
};

        const callGemini = async (prompt, systemPrompt, isJson = true) => {
            try {
                if(!apiKey) throw new Error("API Key is missing. Please edit the HTML file and add your key.");
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        maxOutputTokens: 8192,
                        temperature: 0.8,
                        ...(isJson ? { responseMimeType: "application/json" } : {})
                    }
                };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                return isJson ? JSON.parse(text) : text;
            } catch (error) {
                console.error("Gemini Error:", error);
                throw error;
            }
        };

        const callTTS = async (text) => {
            try {
                if(!apiKey) throw new Error("API Key is missing.");
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                    }
                };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`TTS API Error: ${response.status}`);
                const data = await response.json();
                const base64Audio = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                const binaryString = window.atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                const wavBuffer = pcmToWav(bytes.buffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio.play().catch(e => {
                    console.error("Playback failed:", e);
                    alert("Audio generated but autoplay blocked. Try again.");
                });
            } catch (error) {
                console.error("TTS Error:", error);
                alert("Failed to play audio: " + error.message);
            }
        };

        /* ----------------------------------------------------------------------
          HELPER COMPONENTS
          ----------------------------------------------------------------------
        */
        const ValenceGraph = ({ dataPoints, height = 60 }) => {
            if (!dataPoints || dataPoints.length < 2) return null;
            const maxVal = 10, minVal = -10, range = 20;
            const stepX = 100 / (dataPoints.length - 1);
            const points = dataPoints.map((val, idx) => {
                const normalizedY = 100 - ((val - minVal) / range) * 100;
                return `${idx * stepX},${normalizedY}`;
            }).join(' ');
            const zeroY = 100 - ((0 - minVal) / range) * 100;
            return (
                <div className="w-full" style={{ height: `${height}px` }}>
                    <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" className="overflow-visible">
                        <line x1="0" y1={zeroY} x2="100" y2={zeroY} stroke="#475569" strokeWidth="1" strokeDasharray="4" />
                        <polyline points={points} fill="none" stroke="#6366f1" strokeWidth="2" vectorEffect="non-scaling-stroke" />
                        {dataPoints.map((val, idx) => {
                            const normalizedY = 100 - ((val - minVal) / range) * 100;
                            const color = val > 0 ? '#10b981' : val < 0 ? '#ef4444' : '#94a3b8';
                            return <circle key={idx} cx={`${idx * stepX}`} cy={normalizedY} r="1.5" fill={color} vectorEffect="non-scaling-stroke" />;
                        })}
                    </svg>
                </div>
            );
        };

        const ValenceBadge = ({ score }) => {
            let color = "bg-slate-700 text-slate-300";
            let IconComp = Minus;
            if (score > 0) { color = "bg-emerald-900/40 text-emerald-400 border-emerald-900/50"; IconComp = TrendingUp; }
            else if (score < 0) { color = "bg-red-900/40 text-red-400 border-red-900/50"; IconComp = TrendingDown; }
            return (
                <div className={`flex items-center gap-1 text-[10px] font-mono px-2 py-0.5 rounded border ${color}`}>
                    <IconComp className="w-3 h-3" /> {score > 0 ? '+' : ''}{score}
                </div>
            );
        };

        /* ----------------------------------------------------------------------
          MAIN APP COMPONENT
          ----------------------------------------------------------------------
        */
        function NovelCraft() {
            const [story, setStory] = useState({ concept: "", threads: [], lore: [], cast: [], acts: [], scenes: {}, beats: {}, prose: {} });
            const [view, setView] = useState('setup');
            const [loading, setLoading] = useState(false);
            const [loadingStep, setLoadingStep] = useState("");
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [selectedAct, setSelectedAct] = useState(null);
            const [selectedScene, setSelectedScene] = useState(null);
            const [inputConcept, setInputConcept] = useState("");
            const [pacing, setPacing] = useState(50);
            const fileInputRef = useRef(null);

            const handleWorldUpdates = (updates) => {
                if (!updates) return;
                setStory(prev => {
                    let newCast = [...prev.cast];
                    let newLore = [...prev.lore];
                    if (updates.cast_updates) {
                        updates.cast_updates.forEach(up => {
                            const idx = newCast.findIndex(c => c.name === up.name);
                            if (idx !== -1) {
                                const char = newCast[idx];
                                if (!char.details) char.details = { history: "", story_events: "", goals: "", evolution: "" };
                                if (up.append_history) char.details.history += `\n[New]: ${up.append_history}`;
                                if (up.append_story_events) char.details.story_events += `\n- ${up.append_story_events}`;
                                if (up.update_goals) char.details.goals = up.update_goals;
                                newCast[idx] = char;
                            }
                        });
                    }
                    if (updates.new_characters) {
                        updates.new_characters.forEach(nc => {
                            if (!newCast.find(c => c.name === nc.name)) newCast.push(nc);
                        });
                    }
                    if (updates.lore_updates) {
                        updates.lore_updates.forEach(up => {
                            if (!newLore.find(l => l.topic === up.topic)) newLore.push({ topic: up.topic, detail: up.detail });
                        });
                    }
                    return { ...prev, cast: newCast, lore: newLore };
                });
            };

            const handleExport = () => {
                try {
                    const jsonString = JSON.stringify(story, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `novelcraft_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (err) { alert("Export failed: " + err.message); }
            };

            const handleImport = (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.concept && Array.isArray(imported.acts)) {
                            setStory(imported); setView('dashboard'); alert("Loaded!");
                        } else { alert("Invalid file format."); }
                    } catch (error) { alert("Error: " + error.message); }
                };
                reader.readAsText(file);
                event.target.value = null;
            };

            const initStory = async () => {
                if (!inputConcept) return;
                setLoading(true); setLoadingStep("Architecting Story Bible...");
                try {
                    const bible = await callGemini(`Concept: ${inputConcept}`, PROMPTS.storyArchitect, true);
                    setStory(prev => ({ ...prev, concept: bible.concept, threads: bible.threads, cast: [bible.protagonist], lore: bible.world_lore }));
                    setLoadingStep("Structuring Acts...");
                    const actData = await callGemini(`Concept: ${bible.concept}\nThreads: ${JSON.stringify(bible.threads)}`, PROMPTS.actStructure, true);
                    setStory(prev => ({ ...prev, acts: actData.acts }));
                    setView('dashboard');
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const generateScenes = async (actIndex) => {
                setLoading(true); setLoadingStep(`Weaving Scenes for Act ${actIndex + 1}...`);
                try {
                    const act = story.acts[actIndex];
                    const actNumber = act.number || actIndex + 1;
                    let systemPrompt = PROMPTS.sceneWeaverAct1;
                    if (actNumber === 2) systemPrompt = PROMPTS.sceneWeaverAct2;
                    if (actNumber >= 3) systemPrompt = PROMPTS.sceneWeaverAct3;
                    const res = await callGemini(`Act Context: ${JSON.stringify(act)}\nThreads: ${JSON.stringify(story.threads)}\nCast: ${JSON.stringify(story.cast)}\nLore: ${JSON.stringify(story.lore)}`, systemPrompt, true);
                    setStory(prev => ({ ...prev, scenes: { ...prev.scenes, [actIndex]: res.scenes } }));
                    handleWorldUpdates({ new_characters: res.new_characters });
                    setSelectedAct(actIndex);
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const generateBeats = async (actIdx, sceneIdx) => {
                setLoading(true); setLoadingStep("Directing Beats...");
                try {
                    const res = await callGemini(`Scene: ${JSON.stringify(story.scenes[actIdx][sceneIdx])}\nThreads: ${JSON.stringify(story.scenes[actIdx][sceneIdx].active_thread_ids)}`, PROMPTS.beatDirector, true);
                    const sId = `${actIdx}-${sceneIdx}`;
                    setStory(prev => ({ ...prev, beats: { ...prev.beats, [sId]: res.beats } }));
                    setSelectedScene(sceneIdx);
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const writeProse = async (actIdx, sceneIdx, beatIdx) => {
                setLoading(true);
                const sId = `${actIdx}-${sceneIdx}`;
                const bId = `${sId}-${beatIdx}`;
                const beat = story.beats[sId][beatIdx];
                const scene = story.scenes[actIdx][sceneIdx];
                const prevBeatIdx = beatIdx - 1;
                const prevText = prevBeatIdx >= 0 ? story.prose[`${sId}-${prevBeatIdx}`]?.final : "Start.";
                const activeCast = story.cast.filter(c => scene.cast_names?.includes(c.name));
                const castContext = activeCast.map(c => `Name: ${c.name}\nVoice: ${c.voice_sample}\nGoal: ${c.details?.goals}\nEvents: ${c.details?.story_events}`).join('\n');
                const pacingDesc = pacing < 30 ? "Slow, sensory" : pacing > 70 ? "Fast, action" : "Balanced";

                try {
                    setLoadingStep("Agent 1/3: Drafting...");
                    const draft = await callGemini(`Prev: ${prevText.slice(-500)}\nBeat: ${beat.description}\nValence: ${beat.valence}\nPacing: ${pacingDesc}\nCast: ${castContext}\nLore: ${JSON.stringify(story.lore.slice(0,3))}`, PROMPTS.drafter, false);
                    setLoadingStep("Agent 2/3: Polishing...");
                    const final = await callGemini(`Draft: ${draft}`, PROMPTS.editor, false);
                    setLoadingStep("Agent 3/3: Archiving...");
                    const updates = await callGemini(`Text: ${final}\nCast Summary: ${activeCast.map(c=>c.name).join(', ')}`, PROMPTS.archivist, true);
                    handleWorldUpdates(updates);
                    setStory(prev => ({ ...prev, prose: { ...prev.prose, [bId]: { draft, final } } }));
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const copyFullScene = () => {
                if (selectedAct === null || selectedScene === null) return;
                const scene = story.scenes[selectedAct][selectedScene];
                const sId = `${selectedAct}-${selectedScene}`;
                const beats = story.beats[sId] || [];
                let text = `SCENE ${scene.number}: ${scene.title.toUpperCase()}\n\n`;
                beats.forEach((beat, idx) => {
                    const bId = `${sId}-${idx}`;
                    if (story.prose[bId]?.final) text += story.prose[bId].final + "\n\n";
                });
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.select();
                try { document.execCommand('copy'); alert("Copied!"); } catch (err) { alert("Copy failed."); }
                document.body.removeChild(textArea);
            };

            return (
                <div className="flex h-screen bg-slate-950 text-slate-200 overflow-hidden">
                    <div className={`fixed inset-y-0 left-0 z-50 w-72 bg-slate-900 border-r border-slate-800 flex flex-col transform transition-transform duration-300 md:translate-x-0 ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        <div className="p-4 flex justify-between border-b border-slate-800">
                            <h2 className="font-bold flex gap-2"><Book className="text-indigo-400" /> NovelCraft 2.4</h2>
                            <button onClick={() => setIsSidebarOpen(false)} className="md:hidden"><X /></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-1">
                            <button onClick={() => setView('dashboard')} className={`nav-btn ${view === 'dashboard' ? 'active' : ''}`}><Activity size={16} /> Overview</button>
                            <button onClick={() => setView('cast')} className={`nav-btn ${view === 'cast' ? 'active' : ''}`}><Users size={16} /> Cast & Roster</button>
                            <button onClick={() => setView('lore')} className={`nav-btn ${view === 'lore' ? 'active' : ''}`}><Globe size={16} /> World Lore</button>
                            <button onClick={() => setView('structure')} className={`nav-btn ${view === 'structure' ? 'active' : ''}`}><Layers size={16} /> Act Planner</button>
                            {story.acts.map((act, idx) => (
                                <div key={idx} className="ml-2 mt-2">
                                    <div className="text-[10px] text-slate-500 font-bold uppercase px-3 mb-1">Act {act.number}</div>
                                    {story.scenes[idx]?.map((scene, sIdx) => (
                                        <button key={sIdx} onClick={() => { setSelectedAct(idx); setSelectedScene(sIdx); setView('writer'); setIsSidebarOpen(false); }} className={`nav-btn text-xs pl-6 truncate ${view==='writer' && selectedScene===sIdx ? 'text-indigo-300' : ''}`}>{scene.number}. {scene.title}</button>
                                    ))}
                                </div>
                            ))}
                        </div>
                        <div className="p-4 border-t border-slate-800 flex gap-2">
                            <button onClick={handleExport} className="flex-1 bg-slate-800 hover:bg-slate-700 py-2 rounded text-xs flex justify-center gap-2 transition-colors"><Download size={14} /> Save</button>
                            <button onClick={() => fileInputRef.current.click()} className="flex-1 bg-slate-800 hover:bg-slate-700 py-2 rounded text-xs flex justify-center gap-2 transition-colors"><Upload size={14} /> Load</button>
                            <input type="file" ref={fileInputRef} onChange={handleImport} className="hidden" accept=".json" />
                        </div>
                    </div>

                    <div className="flex-1 flex flex-col h-full relative w-full md:ml-72">
                        <header className="h-16 border-b border-slate-800 bg-slate-900/50 flex justify-between px-6 items-center backdrop-blur-sm z-20">
                            <div className="flex items-center gap-4">
                                <button onClick={() => setIsSidebarOpen(true)} className="md:hidden"><Menu /></button>
                                <h2 className="font-bold text-lg capitalize">{view}</h2>
                                {loading && <span className="text-xs text-indigo-400 flex items-center gap-2"><RefreshCw size={14} className="animate-spin" /> {loadingStep}</span>}
                            </div>
                        </header>

                        <main className="flex-1 overflow-y-auto p-4 md:p-8">
                            {view === 'setup' && (
                                <div className="max-w-xl mx-auto py-20 text-center animate-fade-in">
                                    <div className="bg-indigo-600 w-16 h-16 rounded-2xl flex items-center justify-center mx-auto mb-6"><Sparkles size={32} color="white" /></div>
                                    <h1 className="text-2xl font-bold mb-4">NovelCraft 2.4</h1>
                                    <p className="text-slate-400 mb-6">Enter a concept. The AI Architect will build your story bible.</p>
                                    <textarea className="w-full bg-slate-900 border border-slate-800 rounded-xl p-4 h-32 mb-6 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="e.g. A fantasy world where magic costs memories..." value={inputConcept} onChange={e => setInputConcept(e.target.value)} />
                                    <button onClick={initStory} disabled={loading || !inputConcept} className="w-full bg-indigo-600 hover:bg-indigo-500 py-4 rounded-xl font-bold transition-all disabled:opacity-50">Initialize Story</button>
                                </div>
                            )}

                            {view === 'dashboard' && (
                                <div className="max-w-5xl mx-auto space-y-8 animate-fade-in">
                                    <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                        <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Concept</h3>
                                        <p className="text-xl font-light">{story.concept}</p>
                                    </div>
                                    <div className="grid md:grid-cols-2 gap-6">
                                        <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                            <h3 className="text-xs font-bold text-emerald-400 uppercase mb-4 flex gap-2"><GitBranch size={16}/> Threads</h3>
                                            <div className="space-y-4">{story.threads.map(t => <div key={t.id} className="p-3 bg-slate-950 rounded border border-slate-800/50"><div className="font-bold mb-1">{t.name}</div><div className="text-sm text-slate-400">{t.description}</div></div>)}</div>
                                        </div>
                                        <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                            <h3 className="text-xs font-bold text-blue-400 uppercase mb-4 flex gap-2"><Globe size={16}/> Lore</h3>
                                            <div className="space-y-2">{story.lore.map((l, i) => <div key={i} className="text-sm border-b border-slate-800/50 pb-2 flex gap-2"><span className="text-blue-300 font-mono shrink-0">{l.topic}:</span><span className="text-slate-400">{l.detail}</span></div>)}</div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {view === 'cast' && (
                                <div className="grid md:grid-cols-2 gap-6 max-w-6xl mx-auto animate-fade-in">
                                    {story.cast.map((c, i) => (
                                        <div key={i} className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden">
                                            <div className="p-5 border-b border-slate-800 bg-slate-800/30 flex justify-between">
                                                <div><h3 className="text-xl font-bold">{c.name}</h3><span className="text-xs text-indigo-400 uppercase font-mono">{c.role}</span></div>
                                                <User className="text-slate-600" />
                                            </div>
                                            <div className="p-5 space-y-4">
                                                <div className="grid grid-cols-2 gap-4">
                                                    <div className="bg-slate-950 p-3 rounded border border-slate-800"><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">Status</div><div className="text-sm whitespace-pre-wrap">{c.details?.story_events}</div></div>
                                                    <div className="bg-slate-950 p-3 rounded border border-slate-800"><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">Goal</div><div className="text-sm">{c.details?.goals}</div></div>
                                                </div>
                                                <div><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">History</div><p className="text-sm text-slate-400">{c.details?.history}</p></div>
                                                <div className="bg-indigo-900/10 p-3 rounded border border-indigo-500/20 italic text-indigo-200 font-serif">"{c.voice_sample}"</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {view === 'structure' && (
                                <div className="max-w-4xl mx-auto space-y-6 animate-fade-in">
                                    {story.acts.map((act, idx) => (
                                        <div key={idx} className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden">
                                            <div className="p-6 border-b border-slate-800 flex justify-between items-center bg-slate-800/20">
                                                <div><span className="text-xs font-bold text-slate-500 uppercase">Act {act.number}</span><h3 className="text-xl font-bold">{act.title}</h3><p className="text-sm text-slate-400">{act.description}</p></div>
                                                {!story.scenes[idx] && <button onClick={() => generateScenes(idx)} disabled={loading} className="bg-indigo-600 px-4 py-2 rounded font-bold text-sm hover:bg-indigo-500">Weave Scenes</button>}
                                            </div>
                                            {story.scenes[idx] && <div className="p-4 bg-slate-950/50 border-b border-slate-800"><ValenceGraph dataPoints={story.scenes[idx].map(s => s.valence)} /></div>}
                                            {story.scenes[idx] && <div className="divide-y divide-slate-800">{story.scenes[idx].map((s, si) => (
                                                <div key={si} className="p-4 flex justify-between items-center hover:bg-slate-800/30 group">
                                                    <div className="flex gap-4"><div className="w-8 h-8 rounded-full bg-slate-800 flex items-center justify-center text-xs font-bold text-slate-500">{s.number}</div><div><h4 className="font-bold">{s.title}</h4><p className="text-sm text-slate-500">{s.description}</p></div></div>
                                                    <div className="flex items-center gap-3"><ValenceBadge score={s.valence} /><button onClick={() => { setSelectedAct(idx); setSelectedScene(si); setView('writer'); }} className="text-indigo-400 opacity-0 group-hover:opacity-100 transition-opacity"><Edit3 size={18} /></button></div>
                                                </div>
                                            ))}</div>}
                                        </div>
                                    ))}
                                </div>
                            )}

                            {view === 'writer' && selectedAct !== null && selectedScene !== null && (
                                <div className="max-w-6xl mx-auto space-y-8 animate-fade-in pb-32">
                                    <div className="bg-slate-900 p-6 rounded-xl border border-slate-800 flex justify-between items-start">
                                        <div>
                                            <button onClick={() => setView('structure')} className="text-xs text-slate-500 flex items-center gap-1 mb-2 hover:text-white"><ArrowLeft size={12} /> Back</button>
                                            <div className="flex items-center gap-3 mb-2"><h2 className="text-2xl font-bold">{story.scenes[selectedAct][selectedScene].title}</h2><ValenceBadge score={story.scenes[selectedAct][selectedScene].valence} /></div>
                                            <p className="text-slate-400">{story.scenes[selectedAct][selectedScene].description}</p>
                                        </div>
                                        <div className="flex flex-col gap-2">
                                            <button onClick={copyFullScene} className="bg-slate-800 p-2 rounded hover:bg-slate-700 transition-colors"><Copy size={18} /></button>
                                            {!story.beats[`${selectedAct}-${selectedScene}`] && <button onClick={() => generateBeats(selectedAct, selectedScene)} disabled={loading} className="bg-emerald-600 px-4 py-2 rounded font-bold shadow-lg flex items-center gap-2"><Sparkles size={16} /> Beats</button>}
                                        </div>
                                    </div>
                                    <div className="space-y-12">
                                        {story.beats[`${selectedAct}-${selectedScene}`]?.map((beat, bi) => {
                                            const bId = `${selectedAct}-${selectedScene}-${bi}`;
                                            const prose = story.prose[bId];
                                            return (
                                                <div key={bi} className="flex flex-col xl:flex-row gap-8">
                                                    <div className="xl:w-80 shrink-0">
                                                        <div className={`p-5 rounded-xl border transition-all ${prose ? 'bg-slate-900/40 border-slate-800 opacity-60' : 'bg-slate-900 border-indigo-500/30'}`}>
                                                            <div className="flex justify-between mb-2"><span className="text-xs font-bold text-indigo-400">BEAT {bi + 1}</span><ValenceBadge score={beat.valence} /></div>
                                                            <p className="text-sm font-medium mb-4">{beat.description}</p>
                                                            <div className="text-[10px] text-slate-500 uppercase font-bold italic mb-4">{beat.emotional_shift}</div>
                                                            {!prose && <div className="space-y-4 pt-4 border-t border-slate-800">
                                                                <div className="flex justify-between text-[10px] text-slate-500 uppercase font-bold"><span>Slow</span><span>Fast</span></div>
                                                                <input type="range" value={pacing} onChange={e => setPacing(e.target.value)} />
                                                                <button onClick={() => writeProse(selectedAct, selectedScene, bi)} disabled={loading} className="w-full bg-indigo-600 py-2 rounded font-bold text-sm hover:bg-indigo-500 flex justify-center gap-2"><Feather size={14} /> Write</button>
                                                            </div>}
                                                        </div>
                                                    </div>
                                                    <div className="flex-1">
                                                        {prose ? (
                                                            <div className="relative group/text">
                                                                <div className="absolute -left-4 top-0 bottom-0 w-1 bg-gradient-to-b from-indigo-500/0 via-indigo-500/20 to-indigo-500/0"></div>
                                                                <div className="prose prose-invert max-w-none font-serif text-lg leading-loose text-slate-200" dangerouslySetInnerHTML={{ __html: parseMarkdown(prose.final) }} />
                                                                <div className="mt-2 flex gap-2 opacity-0 group-hover/text:opacity-100 transition-opacity">
                                                                    <button onClick={() => playTTS(prose.final)} className="p-2 bg-slate-900 rounded text-emerald-400 border border-slate-800 hover:text-emerald-300"><Volume2 size={16} /></button>
                                                                    <button onClick={() => writeProse(selectedAct, selectedScene, bi)} className="p-2 bg-slate-900 rounded text-indigo-400 border border-slate-800 hover:text-indigo-300"><RefreshCw size={16} /></button>
                                                                </div>
                                                            </div>
                                                        ) : <div className="h-full border-l-2 border-slate-900/50 ml-6 pl-12 flex flex-col justify-center text-slate-800 italic text-xl select-none"><PenTool className="w-12 h-12 mb-4 opacity-10" /> Waiting...</div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </main>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<NovelCraft />);
    </script>
</body>
</html>
