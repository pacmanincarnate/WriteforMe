<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EllipsisProse 0.412 - AI Story Architect</title>

    <!-- 1. Tailwind CSS (Styling) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 2. React & ReactDOM (Core Framework) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- 3. Babel (JSX Compiler) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Lucide Icons (Visuals) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 5. JSZip (EPUB Export) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Custom Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&display=swap');

        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            /* Prevent horizontal scroll on mobile */
        }

        /* iOS Input Zoom FIx */
        @media screen and (max-width: 1300px) {

            input,
            textarea,
            select {
                font-size: 16px !important;
            }
        }

        .font-serif {
            font-family: 'Merriweather', serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            margin-top: -6px;
            border: 2px solid #fff;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }

        /* Typography & Utility */
        .prose p {
            margin-bottom: 1.5em;
            line-height: 1.8;
        }

        .prose strong {
            color: #f8fafc;
            font-weight: 700;
        }

        .prose em {
            color: #cbd5e1;
            font-style: italic;
        }

        .nav-btn {
            width: 100%;
            text-align: left;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
            color: #94a3b8;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background-color: #1e293b;
            color: #f1f5f9;
        }

        .nav-btn.active {
            background-color: rgba(79, 70, 229, 0.15);
            color: #a5b4fc;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 1. API CONFIGURATION ---
        // API Key is now managed via UI/LocalStorage in the component


        // --- 2. ICON SYSTEM SETUP ---
        // Helper to render Lucide icons in React without the full library build
        const Icon = ({ name, className, ...props }) => {
            const ref = React.useRef(null);
            React.useEffect(() => {
                if (ref.current) {
                    lucide.createIcons({
                        root: ref.current
                    });
                }
            }, [name, className]);
            return <span ref={ref} style={{ display: 'contents' }}><i data-lucide={name} className={className} {...props}></i></span>;
        };

        // Map component names to Lucide icon names (kebab-case)
        const Book = (p) => <Icon name="book" {...p} />;
        const Layers = (p) => <Icon name="layers" {...p} />;
        const Film = (p) => <Icon name="film" {...p} />;
        const Feather = (p) => <Icon name="feather" {...p} />;
        const ChevronRight = (p) => <Icon name="chevron-right" {...p} />;
        const ChevronDown = (p) => <Icon name="chevron-down" {...p} />;
        const Sparkles = (p) => <Icon name="sparkles" {...p} />;
        const Save = (p) => <Icon name="save" {...p} />;
        const RefreshCw = (p) => <Icon name="refresh-cw" {...p} />;
        const Edit3 = (p) => <Icon name="edit-3" {...p} />;
        const ArrowLeft = (p) => <Icon name="arrow-left" {...p} />;
        const FileText = (p) => <Icon name="file-text" {...p} />;
        const Settings = (p) => <Icon name="settings" {...p} />;
        const AlertCircle = (p) => <Icon name="alert-circle" {...p} />;
        const Menu = (p) => <Icon name="menu" {...p} />;
        const X = (p) => <Icon name="x" {...p} />;
        const Users = (p) => <Icon name="users" {...p} />;
        const User = (p) => <Icon name="user" {...p} />;
        const Target = (p) => <Icon name="target" {...p} />;
        const Brain = (p) => <Icon name="brain" {...p} />;
        const Globe = (p) => <Icon name="globe" {...p} />;
        const PenTool = (p) => <Icon name="pen-tool" {...p} />;
        const GitBranch = (p) => <Icon name="git-branch" {...p} />;
        const Zap = (p) => <Icon name="zap" {...p} />;
        const Trash2 = (p) => <Icon name="trash-2" {...p} />;
        const Download = (p) => <Icon name="download" {...p} />;
        const Upload = (p) => <Icon name="upload" {...p} />;
        const Activity = (p) => <Icon name="activity" {...p} />;
        const History = (p) => <Icon name="history" {...p} />;
        const Play = (p) => <Icon name="play" {...p} />;
        const Volume2 = (p) => <Icon name="volume-2" {...p} />;
        const Loader2 = (p) => <Icon name="loader-2" {...p} />;
        const Square = (p) => <Icon name="square" {...p} />;
        const Copy = (p) => <Icon name="copy" {...p} />;
        const MessageSquare = (p) => <Icon name="message-square" {...p} />;
        const Eye = (p) => <Icon name="eye" {...p} />;
        const CheckCircle2 = (p) => <Icon name="check-circle-2" {...p} />;
        const Sliders = (p) => <Icon name="sliders" {...p} />;
        const TrendingUp = (p) => <Icon name="trending-up" {...p} />;
        const TrendingDown = (p) => <Icon name="trending-down" {...p} />;
        const Minus = (p) => <Icon name="minus" {...p} />;
        const Scroll = (p) => <Icon name="scroll" {...p} />;
        const Search = (p) => <Icon name="search" {...p} />;


        /* ----------------------------------------------------------------------
          UTILS: AUDIO & MARKDOWN
          ----------------------------------------------------------------------
        */




        const pcmToWav = (pcmData, sampleRate = 24000) => {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            const pcmBytes = new Uint8Array(pcmData);
            const wavBytes = new Uint8Array(buffer, 44);
            wavBytes.set(pcmBytes);
            return buffer;
        };

        const parseMarkdown = (text) => {
            if (!text) return "";
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br />');
            return `<p>${html}</p>`;
        };

        /* ----------------------------------------------------------------------
          GEMINI PROMPTS
          ----------------------------------------------------------------------
        */
        const PROMPTS = {
            storyArchitect: `You are a Lead Narrative Designer. Input: A concept. Task: Deconstruct this into a rich Story Bible.

  REQUIREMENTS:
  1. STATUS QUO: Define the "Normal World" before the plot begins.
  2. INCITING INCIDENT: Define the specific event that breaks the status quo.
  3. PROTAGONIST: Deep dive into personality, flaws, and specific voice.
  4. THEMES: What philosophical or emotional questions are being explored?
  5. STYLE: Define the Genre, Mood, and specific Writing Style (e.g., "Hemingway-esque", "Purple Prose", "Fast-paced Thriller").

  Output JSON:
  {
      "concept": "Refined summary",
      "status_quo": "Description of the normal world...",
      "inciting_incident": "The specific event...",
      "themes": "The core ideas being explored...",
      "style": { 
          "genre": "...", 
          "mood": "...", 
          "writing_guide": "Instructions for the writer agent on tone/voice" 
      },
      "threads": [
          { "id": "t1", "name": "Main Arc", "description": "..." },
          { "id": "t2", "name": "Relationship Arc", "description": "..." },
          { "id": "t3", "name": "Subplot Arc", "description": "..." }
      ],
      "protagonist": {
          "name": "Name",
          "role": "Protagonist",
          "description": "Physical & Personality",
          "voice_sample": "Dialogue sample",
          "details": {
              "history": "Backstory...",
              "story_events": "Start...",
              "goals": "...",
              "evolution": "..."
          }
      },
      "world_lore": [{ "topic": "Setting", "detail": "...", "related_to": ["Related Topic"] }]
  }`,

            actStructure: `You are an author working to develop the structure of a story.
Task: Define the structure of the story in exactly 3 Acts, building a compelling and engaging story arc.
Input: Concept, Threads.

You are now operating at the highest altitude of storytelling. You are not looking at the bricks (beats), the walls (scenes), or the wings (sequences). You are looking at the entire building.
Defining Acts is about structuring the protagonist's Global Metamorphosis.

Here is how to approach the architecture of your story's Acts:

1. The Mental Model: The Tripod
Most stories naturally settle into three distinct movements, often called the "Three-Act Structure." Think of them as three different worlds the character must inhabit.

Act I (The Thesis): The Status Quo. This is the world that needs to change.
Act II (The Antithesis): The Upside-Down World. This is the crucible of conflict.
Act III (The Synthesis): The New Reality. This is the world reborn after the conflict.

The Directive: Do not view Acts as just "beginning, middle, and end." View them as distinct psychological phases.
Act I asks: "What is the problem?"
Act II asks: "How hard is it to fix?"
Act III asks: "What is the price of fixing it?"

2. Act I: The Lock-In (The Setup)
Your goal in Act I is not just to introduce names and faces. It is to destabilize the protagonist.
The Job: You must establish what the protagonist wants and, more importantly, what they are afraid of.
The Exit Door (Plot Point 1): Act I must end with a decision that acts as a one-way door. The protagonist must voluntarily choose to leave their "Normal World" to pursue a goal. Once they cross this threshold, there is no turning back.

3. Act II: The Grinder (The Confrontation)
This is the "meat" of the story (usually 50% of the length). It is where most authors get lost (the "Saggy Middle").

The Job: This Act is about failure. The protagonist tries to solve the problem using their old methods, and those methods fail. They are stripped of their defenses.
The Midpoint: Somewhere in the dead center, something must happen that shifts the protagonist from passive (reacting to the villain) to active (attacking the villain). The stakes are raised significantly.
The Exit Door (The All Hope Is Lost Moment): Act II ends when the protagonist hits rock bottom. They have lost their mentorship, their plan, or their hope. They are forced to confront their own internal flaw to survive.
The Directive: Be cruel. Every time the hero thinks they have a foothold, kick it away. If Act II goes smoothly for the hero, there is no drama.

4. Act III: The Proof (The Resolution)
This is the final exam.
The Job: The protagonist must prove they have changed. They must face the antagonist one last time, but this time, they use the lesson they learned in the despair of Act II.
The Climax: This is the singular moment of highest tension in the entire book. The external goal (defeat the villain) and internal goal (overcome the flaw) collide.
THREAD REQUIREMENT:
- Define 2-3 "Convergence Events" (Knots) per act.
- A Knot is where threads intersect: an advancement in Thread A creates a complication for Thread B (or vice versa).

Now write a detailed description of each Act, including your goals for each Act as the author, the focus threads, and the knots. Consider all of the following:
Where does the character begin this Act? (e.g., Act I Start: Living a normal, unsatisfied life.)
What is the massive event that ends this Act and forces the story into a new phase? (e.g., Act I End: Choosing to leave home and enter the dangerous new world.)
Define the "Act Value Shift." If Act I starts in Safety and ends in Danger, every scene you map must contribute to that erosion of safety.

This description is for you as the author, not the reader. The reader will never see this description. Do not worry about giving away too much information. This is an important step in the process of developing the story for yourself.

Output JSON:
  {
    "acts": [
      { "number": 1, "title": "descriptive and catchy title", "description": "full description of act fulfilling the goals for Act 1 from above", "focus_thread_ids": ["t1"], "knots": [ { "description": "Event description...", "interaction": "Thread 1 event forces Thread 2 crisis" } ] },
      { "number": 2, "title": "descriptive and catchy title", "description": "full description of act fulfilling the goals for Act 2 from above", "focus_thread_ids": ["t1", "t2"], "knots": [ { "description": "Event description...", "interaction": "Thread 1 event forces Thread 2 crisis" } ] },
      { "number": 3, "title": "descriptive and catchy title", "description": "full description of act fulfilling the goals for Act 3 from above", "focus_thread_ids": ["t1", "t2"], "knots": [ { "description": "Event description...", "interaction": "Thread 1 event forces Thread 2 crisis" } ] }
    ]
  }`,

            sceneWeaverAct1: `You are an author developing the first act of your story.
Task: Create scenes for ACT 1.
Consider the following guidelines for how to think about scenes within an act:
- You cannot map the journey if you don't know the destination. Before you list a single scene, consider the Act's endpoints.
 - The Act Start: Where does the character begin this phase? (e.g., Act I Start: Living a normal, unsatisfied life.)
 - The Act Climax: What is the massive event that ends this Act and forces the story into a new phase? (e.g., Act I End: Choosing to leave home and enter the dangerous new world.)
 - The Directive: Define the "Act Value Shift." If Act I starts in Safety and ends in Danger, every scene you map must contribute to that erosion of safety.
- Think of the act as a series of sequences; clusters of 2-5 scenes that are tightly linked by a single, short-term goal.
- Each scene must have a clear, single purpose. It must advance the plot, reveal character, or both.
- Follow the Law of Causality: Each scene must occur because of something that happened in the previous scene and must cause something to happen in the next scene ("Therefore," not "and then").
- Manage the Tension Curve: You are the DJ of the audience's heart rate. You cannot have 10 "High Intensity" scenes in a row (exhausting), nor 10 "Low Intensity" scenes (boring).
 - Varied Pacing: Map your scenes to oscillate. Follow a high-stakes action scene with a slower, introspective sequel scene to let the character (and reader) breathe.
 - Rising Action: Ensure the overall trend line is going up. The stakes in Scene 10 must be higher than in Scene 1.
- The Act Climax (The Point of No Return): You must design the final scene of the act to be irreversible. Think of the end of the act as a one-way gate. Once the character passes through it, they cannot go back to the way things were.
- Be clear about where the scene is located; its setting, and its characters. Without this, the writer is likely to move the next scene to an incorrect location.

PACING REQUIREMENT:
- Generate between 12-16 scenes.
- SCENES 1-3 MUST BE SETUP ONLY. Do not start the Inciting Incident yet. Establish the "Status Quo".
- SCENES 4-5: The Inciting Incident (The disruption).
- SCENES 6-12: The Debate & Preparation.
- FINAL SCENE: The Crossing of the Threshold (Point of No Return).
Include "World Building" scenes where plot is slow but atmosphere is high.
Include "Character Bonding" scenes.
THREAD INTERACTION (Causality):
- Isolation: Only advances one thread.
- Collision: Two threads conflict (e.g., Duty vs. Love).
- Resonance: Two threads thematically align.
*ROSTER CHECK*: If you introduce NEW major characters to fulfill these scenes, list them in "new_characters".

It is crucial that the scene descriptions expand fully on what is happening and what your intent is for the scene. Without this, the writing process has too little to work off of. This description is **NOT** for the reader; it is for the writer to fully understand the scene and its purpose.

Output JSON:
  {
    "scenes": [
      { 
        "number": 1, 
        "title": "Scene Title", 
        "description": "Plot events", 
        "active_thread_ids": ["t1"], 
        "location": "Setting", 
        "cast_names": ["Hero"], 
        "valence": 0,
        "causality": { 
            "interaction_type": "Isolation", 
            "description": "Establishes Hero's boredom (Thread A)." 
        }
      }
    ],
    "new_characters": [ { "name": "...", "role": "...", "description": "...", "voice_sample": "...", "details": { "history": "...", "goals": "...", "evolution": "..." } } ]
  }`,

            sceneWeaverAct2: `You are an author developing the second (middle) act of your story.
  Task: Create scenes for ACT 2.
  
  Consider the following guidelines for how to think about scenes within an act:
- You cannot map the journey if you don't know the destination. Before you list a single scene, consider the Act's endpoints.
 - The Act Start: Where does the character begin this phase? (e.g., Act I Start: Living a normal, unsatisfied life.)
 - The Act Climax: What is the massive event that ends this Act and forces the story into a new phase? (e.g., Act I End: Choosing to leave home and enter the dangerous new world.)
 - The Directive: Define the "Act Value Shift." If Act I starts in Safety and ends in Danger, every scene you map must contribute to that erosion of safety.
- Think of the act as a series of sequences; clusters of 2-5 scenes that are tightly linked by a single, short-term goal.
- Each scene must have a clear, single purpose. It must advance the plot, reveal character, or both.
- Follow the Law of Causality: Each scene must occur because of something that happened in the previous scene and must cause something to happen in the next scene ("Therefore," not "and then").
- Manage the Tension Curve: You are the DJ of the audience's heart rate. You cannot have 10 "High Intensity" scenes in a row (exhausting), nor 10 "Low Intensity" scenes (boring).
 - Varied Pacing: Map your scenes to oscillate. Follow a high-stakes action scene with a slower, introspective sequel scene to let the character (and reader) breathe.
 - Rising Action: Ensure the overall trend line is going up. The stakes in Scene 10 must be higher than in Scene 1.
- The Act Climax (The Point of No Return): You must design the final scene of the act to be irreversible. Think of the end of the act as a one-way gate. Once the character passes through it, they cannot go back to the way things were.
- Be clear about where the scene is located; its setting, and its characters. Without this, the writer is likely to move the next scene to an incorrect location.

  PACING REQUIREMENT:
  - Generate between 18-24 scenes. This is the main meat of the book.
  - FIRST HALF: Fun & Games / Training / Testing the waters.
  - MIDPOINT (Roughly Scene 10-12): A major realization or shift in power. Stakes raised.
  - SECOND HALF: The Bad Guys Close In. Failures cost more.
  - FINAL SCENE: Total Crisis (All Hope is Lost).
  
  Slow down the middle. Allow characters to fail small before failing big.
  Include "Campfire Scenes" in which characters reflect on the journey (not necessarily an actual campfire).
  
  THREAD INTERACTION (Causality):
  - Isolation: Only advances one thread.
  - Collision: Two threads conflict (e.g., Duty vs. Love).
  - Resonance: Two threads thematically align.

  VALENCE: High oscillation. The end of the Act must have a strong NEGATIVE valence (-8 to -10) representing the crisis.
  *ROSTER CHECK*: If you introduce NEW major characters, list them in "new_characters".
  
  It is crucial that the scene descriptions expand fully on what is happening and what your intent is for the scene. Without this, the writing process has too little to work off of. This description is **NOT** for the reader; it is for the writer to fully understand the scene and its purpose.

  Output JSON:
  {
    "scenes": [ { "number": 1, "title": "Scene Title", "description": "...", "active_thread_ids": ["t1"], "location": "...", "cast_names": ["..."], "valence": -5, "causality": { "interaction_type": "Collision", "description": "..." } } ],
    "new_characters": []
  }`,

            sceneWeaverAct3: `You are an author developing the third and final act of your story.
  Task: Create scenes for ACT 3.
  
  Consider the following guidelines for how to think about scenes within an act:
- You cannot map the journey if you don't know the destination. Before you list a single scene, consider the Act's endpoints.
 - The Act Start: Where does the character begin this phase? (e.g., Act I Start: Living a normal, unsatisfied life.)
 - The Act Climax: What is the massive event that ends this Act and forces the story into a new phase? (e.g., Act I End: Choosing to leave home and enter the dangerous new world.)
 - The Directive: Define the "Act Value Shift." If Act I starts in Safety and ends in Danger, every scene you map must contribute to that erosion of safety.
- Think of the act as a series of sequences; clusters of 2-5 scenes that are tightly linked by a single, short-term goal.
- Each scene must have a clear, single purpose. It must advance the plot, reveal character, or both.
- Follow the Law of Causality: Each scene must occur because of something that happened in the previous scene and must cause something to happen in the next scene ("Therefore," not "and then").
- Manage the Tension Curve: You are the DJ of the audience's heart rate. You cannot have 10 "High Intensity" scenes in a row (exhausting), nor 10 "Low Intensity" scenes (boring).
 - Varied Pacing: Map your scenes to oscillate. Follow a high-stakes action scene with a slower, introspective sequel scene to let the character (and reader) breathe.
 - Rising Action: Ensure the overall trend line is going up. The stakes in Scene 10 must be higher than in Scene 1.
- The Act Climax (The Point of No Return): You must design the final scene of the act to be irreversible. Think of the end of the act as a one-way gate. Once the character passes through it, they cannot go back to the way things were.
- Think of every scene as a self-contained narrative unit.
- Be clear about where the scene is located; its setting, and its characters. Without this, the writer is likely to move the next scene to an incorrect location.


  PACING REQUIREMENT:
  - Generate 10-14 scenes.
  - SCENES 1-3: The Assessment/Dark Night. Characters pick up the pieces.
  - SCENES 4-5: The Plan. Formulating a desperate strategy.
  - SCENES 6-9: The Climax. Head-on conflict. The threads intersect.
  - FINAL SCENES: The Denouement (New Normal). Show how the world has changed. Reflect on the "Original Normal" from Act 1.
  
  THREAD INTERACTION (Causality):
  - Isolation: Only advances one thread.
  - Collision: Two threads conflict (e.g., Duty vs. Love).
  - Resonance: Two threads thematically align.

  VALENCE: Start low (from Act 2 crisis), rise to tension, end High Positive (Resolution).

  It is crucial that the scene descriptions expand fully on what is happening and what your intent is for the scene. Without this, the writing process has too little to work off of. This description is **NOT** for the reader; it is for the writer to fully understand the scene and its purpose.
  
  Output JSON:
  {
    "scenes": [ { "number": 1, "title": "Scene Title", "description": "...", "active_thread_ids": ["t1"], "location": "...", "cast_names": ["..."], "valence": 5, "causality": { "interaction_type": "Resonance", "description": "..." } } ],
    "new_characters": []
  }`,

            beatDirector: `You are the architect of a single narrative scene within a larger act. Before you draft the prose, you must draft the blueprint. You are not writing dialogue yet; you are designing the structural integrity of the narrative arc. A scene is a story in miniature. It must have its own beginning, middle, and end. It must have its own inciting incident, rising action, and climax.


  Task: Break the scene into 6-10 distinct beats.
  Input: Scene context, Threads involved.
  Requirement: Vary the type of beats (Action, Reaction, Revelation, Resolution).
  
  VALENCE: Assign a "valence" score (-10 to +10) to each beat. 
  Oscillate between positive and negative beats to maintain tension.

    Here is your framework for mapping out a successful sequence of beats. This is expected to be a paragraph or more.
    1. Define the State Change
    Consider the scene's endpoints. You must know the exact distance the character needs to travel emotionally or logically.
    Consider exactly what the protagonist believes, feels, or possesses at the start of the scene. Consider the inverted state at the end of the scene. Ensure the exit state is irreversible within the context of this scene. The characters cannot simply "reset" to the beginning once the scene ends.
    2. Inventory the Tactics
    Consider the specific actions your characters are willing to take to achieve their goal. Do not think in terms of "conversation topics." Think in terms of strategic maneuvers.
    The Directive: Select only tactics that fit these characters' personalities and the resources they have available at this moment.
    3. Sequence by Escalation
    Arrange your inventory of tactics into a logical order of increasing intensity/risk. This creates the "rising action" of the scene.
    Map the first beat as the path of least resistance—the lowest "cost" tactic. Map subsequent beats to require more emotional capital or risk from the characters.
    4. Engineer the Pivot
    Designate a single beat as the structural center of the scene—the "Turning Point."
    Locate the Shift: Mark the specific beat where the value charge flips (e.g., from Positive to Negative). Build the surrounding beats to support this moment. The beats before it should build tension toward it; the beats after it should process the fallout from it.
    5. Verify the Causality
    Review your map to ensure strict cause-and-effect logic.
    Link the Beats: Ensure that Beat B is the only logical reaction to Beat A, and the only logical setup for Beat C.

    Here is your guide for crafting a successful beat.
    - Your Mantra for each beat: "Someone wants something. Someone opposes it. Something changes. Next beat."
    - The most critical thing an author considers is the emotional or logical shift. Robert McKee, a legendary screenwriting lecturer, defines a beat as an exchange of behavior in action/reaction which shapes the turning of a relationship. "Does this beat move the scene closer to or further away from the character's goal?"
    - The Beat Function: How does this specific beat get them closer to that goal or throw a specific obstacle in their way?
    - Focus on what each character is trying to **do** to each other in this beat and what their intentions are. Assign an active verb (a tactic) to the beat to ensure the characters are active, not passive. Think about what the characters want in this specific beat and how they attempt to achieve that.
    - Create a gap between expectation and reality to keep the narrative unpredictable and force the characters to think on their feet. Authors plan beats as a game of tennis. They focus on the causality. What causes the character to act? Is it an external threat, an internal realization, or a line of dialogue from someone else? Is the reaction immediate (instinctive) or delayed (calculated)? Authors look for the gap between what a character expects to happen when they take an action, and what actually happens. The beat usually lands in that gap of surprise.
    - Ensure that each beat involves an emotional change. The characters should feel different after the beat completes than when it began.

    Ensure that each of your beat descriptions thoroughly and completely addresses each point above so that each beat actively contributes to the story and character development in a coherent, immersive, unexpected, and compelling way. It is crucial that beat descriptions expand fully on what is happening and what your intent is for the beat. Without this, the writing process has too little to work off of.
  
  PACING: Assign a pacing score (0, 1, or 2) to each beat.
  - 0 (Slow): Atmospheric, introspection, sensory details. Use for setup and sequels.
  - 1 (Balanced): Dialogue-heavy, standard narrative flow.
  - 2 (Fast): Action, high tension, rapid-fire decisions. Use for climaxes and conflicts.

  Output JSON:
  {
    "beats": [
      { "number": 1, "type": "Action/Reaction/Dialogue", "description": "description of what happens, who is in the beat, what they want, what they do, and a full discussion on the authorial intent for the beat", "emotional_shift": "How the mood changes", "valence": 4, "pacing": 1 }
    ]
  }`,

            drafter: `You are an award-winning author working on your next novel. Given the information below, write the prose for the CURRENT BEAT in 400-600 words. It is essential that the text flow smoothly from the previous beat and end just before the next beat.

# CONTEXT
## Scene Description
{scene_description}

## Mood & Pacing
- Subtext: {subtext}
- {pacing}
- Valence: {valence}
  
## Style & Tone
{style_guide}

## Characters Present
{voices}

## Relevant Lore
{lore}
  
Here is your guide for crafting a successful beat.
- Your Mantra for the beat: "Someone wants something. Someone opposes it. Something changes. Next beat."
- The most critical thing an author considers is the emotional or logical shift. Robert McKee, a legendary screenwriting lecturer, defines a beat as an exchange of behavior in action/reaction that shapes the turning of a relationship. "Does this beat move the scene closer to or further away from the character's goal?"
- The Beat Function: How does this specific beat get them closer to that goal or throw a specific obstacle in their way?
- Focus on what each character is trying to **do** to each other in this beat and what their intentions are. Assign an active verb (a tactic) to the beat to ensure the characters are active, not passive. Think about what the characters want in this specific beat and how they attempt to achieve that.
- Create a gap between expectation and reality to keep the narrative unpredictable and force the characters to think on their feet. Authors plan beats as a game of tennis. They focus on the causality. What causes the character to act? Is it an external threat, an internal realization, or a line of dialogue from someone else? Is the reaction immediate (instinctive) or delayed (calculated)? Authors look for the gap between what a character expects to happen when they take an action, and what actually happens. The beat usually lands in that gap of surprise.
- Ensure that the beat involves an emotional change. The characters should feel different after the beat completes than when it began.`,

            editor: `You are a Ruthless Editor working with a writer to clean up their draft.
Task: Polish the following draft.
Rules:
1. Cut exposition.
2. Strengthen verbs.
3. Ensure character voice matches their personality and current mood as inferred from the prose.
4. Fix "filter words" (e.g., change "He saw the box" to "The box sat on the table").
5. HIGH PRIORITY: Check for and remove continuity errors such as a character referencing future events. Look closely at the beat before and the beat after the current text and ensure that the current beat fits *within* those beats. Rewrite the beat to maintain continuity where required to avoid invalidating future beats.
6. The dialogue needs to be written to give each character a *very* distinct voice.
7. Ensure that characters are actively pursuing their own goals within the scene.
8. Refine subtext: Ensure that there is a clear tension between what characters say and what they feel.
9. Remove repetition and 'crutch' words, such as ozone, whisper, and sternum.
10. Ensure there is a clear cause and effect within the beat. It is important that the beat shift the emotional state of the characters in a noticeable and clear way.
11. Revise circular dialogue or events to force characters to change their approach to prevent static, stale action.
12. Ensure that character reactions follow the pattern of: visceral, emotional, intellectual, action/speech. This applies to well-developed characters as well as supporting characters.

# CONTEXT
This is the important information to keep in mind as you review the work.

## Scene Description
{scene_description}

## Mood & Pacing
- Subtext: {subtext}
- {pacing}
- Valence: {valence}
  
## Style & Tone
{style_guide}

## Characters Present
It's essential that each character's voice shines through in their speech, mannerisms, and actions. They should each be clearly driven by personal goals.
{voices}


# CONTEXT
## Act Scene List
{scene_list}

## Current Scene Beats Outline
{scene_beats}

## Previous Beat Text
{prev_beat_text}


# Input: Current Beat Draft: {draft}
Output: Plain Text (The Final Polish).`,

            archivist: `You are the Story Archivist.
Task: Analyze the just-written text and return UPDATES for the Story Bible.
  
Text Segment: {text}
Current Cast: {cast_summary}

EXISTING LORE: 
{current_lore}
  
1. CAST UPDATES: 
- Did a character reveal new Backstory (History)?
- Did a major Event just happen to them? (Add to Story Events)
- Did their Goal change?
2. LORE UPDATES:
- Was a new location or object described in detail?
- Look for 'Chekhov's Gun'; the seemingly inconsequential detail that may become important later.
- LIMIT: Generate 1-4 items maximum.
- DUPLICATION CHECK: Do not create lore for topics that already exist in the provided list.
  
  Output JSON:
  {
    "cast_updates": [
      { "name": "Hero", "append_history": "...", "append_story_events": "...", "update_goals": "..." }
    ],
    "lore_updates": [
      { "topic": "...", "detail": "...", "related_to": ["..."] }
    ]
  }`,

            beatValidator: `You are a Script Doctor.
CONTEXT:
The plan for the NEXT beat was: "{next_beat_desc}"
The Scene Goal is: "{scene_goal}"

REALITY:
The Author just wrote: "{prose_summary}"

TASK:
Does the Prose logically allow the Next Beat to happen as written?
- If YES: Return valid: true.
- If NO (e.g. Character A left the room, but Next Beat requires them to speak): 
Return valid: false.
REWRITE the remaining beats for this scene to accommodate the new reality while still steering toward the Scene Goal. Avoid lengthening the scene.
  
  Output JSON:
  {
    "valid": true/false,
    "reason": "Why it is invalid...",
    "rectified_beats": [ 
       { "number": N, "type": "...", "description": "...", "emotional_shift": "...", "valence": 0, "pacing": 1 }
    ]
  }`,

            characterExtractor: `You are a Casting Director.
  Task: Identify all distinct characters mentioned in the provided Story Bible text.
  Input: Story Bible JSON.
  
  Rules:
  1. Include the Protagonist (if not already redundant).
  2. Identify Antagonists, Sidekicks, Mentors, or significant figures mentioned in threads/history.
  3. Extract a brief description, their role, and their GOAL for each.
  
  Output JSON:
  {
    "characters": [
      { "name": "Name", "role": "Role (e.g. Antagonist)", "description": "Brief summary", "goals": "What do they want?", "context": "Mentioned in..." }
    ]
  }`,

            characterGenerator: `You are an expert Character Profiler and Method Actor.
Task: Generate a deep, first-person character profile that sounds exactly like a transcript of an interview with the character from **before** the story takes place.
Input: Basic character details (name, role, context) AND Global Story Context.

REQUIREMENTS:
1.  **Context Integration (CRITICAL)**: You MUST integrate the Story Concept, Themes, and Style into the character's voice and worldview.
    - If the theme is "Loss of Humanity," the character should speak with detachment or obsession about what they've lost.
    - If the setting is "Cyberpunk," use appropriate slang and reference technology/corporations.
    - The character must feel like they grew up in THIS specific world, not a generic one.
2.  **Voice & Tone**: The entire output must be in the character's unique voice. 
3.  **Content**: Cover their Backstory, Motivations, Fears, Relationships, and Secrets.
    - *Specifics*: Avoid generic tropes. Give them a specific, weird habit or a very specific memory.
4.  **Mannerisms**: Include non-verbal cues in the text (e.g., he sips his drink, she pauses, deep in thought, he laughs nervously).
5.  **No Meta-Commentary**: Do not write "Here is the profile." Just START talking as the character.

Output Format: Just the raw text of the character speaking.`,

            loreScheduler: `You are a Continuity Manager.
Task: Assign a "Revelation Point" (Act & Scene) to each item of World Lore.
Input: Story Concept, Act Outline, and List of Lore Items.

Rules:
1.  **Spoilers**: If a piece of lore is a plot twist or secret discovered later, set its Act/Scene to when it is revealed.
2.  **Background**: If a piece of lore is general knowledge or background history, set it to Act 1, Scene 1.
3.  **Progression**: Ensure lore is distributed logically. Not everything should be known at the start.

Output JSON:
{
  "lore_schedule": [
    { "topic": "Name of Lore Topic", "valid_from_act": 1, "valid_from_scene": 1 },
    { "topic": "Secret Weapon", "valid_from_act": 3, "valid_from_scene": 5 }
  ]
}`,

            loreSelector: `You are a Narrative Context Engine.
Task: Select the MOST RELEVANT lore items for the current scene beat.
Input: Current Scene Description, Current Beat Description, List of Available Lore.

Rules:
1.  **Relevance**: Only select lore that is directly actionable or thematically relevant to *this specific beat*.
2.  **Limit**: Select a maximum of 3-5 items. If nothing is relevant, return an empty list.
3.  **Context**: Consider the location, characters present, and the action occurring.

Output JSON:
{
  "selected_lore_topics": ["Topic A", "Topic B"]
}`,

            loreDistiller: `You are an impartial World Data Analyst.
Task: Analyze the provided text and extract the "World Primer".
Input: Unknown Text (could be any genre).

REQUIREMENTS:
1.  **Genre-Agnostic Tone**: Do NOT use genre-specific labels (e.g., do not say "Magic System" or "Sci-Fi Tech"). Instead use neutral terms like "Operational Rules", "Key Entities", "Environmental Conditions", "History".
2.  **Focus**: Extract high-level rules that apply generally to the world, rather than specific plot events.
3.  **Brevity**: Summarize into approx. 800-1000 words.
4.  **Structure**:
    - **Operational Rules**: The physics, metaphysics, or laws of the world.
    - **Key Entities**: Major groups, factions, or species.
    - **Environment**: Layout, geography, or atmosphere.
    - **Tone/Style**: The feeling of the setting.

Output: Plain Text Summary.`
        };



        const cleanJson = (text) => {
            if (!text) return "";
            // Find the first open brace and the last close brace to fallback if code blocks aren't cleaner
            // But first, try to capture a code block if it exists, as that's explicit
            const match = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (match) return match[1].trim();

            // If no code block, just find the outer braces
            const start = text.indexOf('{');
            const end = text.lastIndexOf('}');
            if (start !== -1 && end !== -1 && end > start) {
                return text.substring(start, end + 1);
            }
            return text.trim();
        };

        const getValenceDescription = (score) => {
            const num = parseInt(score, 10);
            if (isNaN(num)) return "Neutral";
            if (num <= -8) return "Catastrophic / Despair";
            if (num <= -5) return "Dangerous / Critical Failure";
            if (num <= -2) return "Negative / Tense";
            if (num <= 1) return "Uncertain / Neutral";
            if (num <= 4) return "Positive / Hopeful";
            if (num <= 7) return "Success / Joyous";
            return "Amazing / Triumphant";
        };

        const callGemini = async (apiKey, model, prompt, systemPrompt, isJson = true) => {
            try {
                const key = apiKey ? apiKey.trim() : "";
                if (!key) throw new Error("API Key is missing. Please add it in Settings.");
                const modelId = model || "gemini-2.0-flash";
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        maxOutputTokens: 8192,
                        temperature: 0.8,
                        ...(isJson ? { responseMimeType: "application/json" } : {})
                    }
                };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (isJson) {
                    try {
                        return JSON.parse(cleanJson(text));
                    } catch (e) {
                        console.error("Gemini JSON Parse Error. Raw Text:", text);
                        throw new Error("Failed to parse AI response as JSON. Check console for details.");
                    }
                }
                return text;
            } catch (error) {
                console.error("Gemini Error:", error);
                throw error;
            }
        };

        const callTTS = async (apiKey, text) => {
            try {
                const key = apiKey ? apiKey.trim() : "";
                if (!key) throw new Error("API Key is missing. Please add it in Settings.");
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                    }
                };

                // Using gemini-2.0-flash-exp for experimental audio features if standard flash doesn't fully support yet, 
                // but usually 'gemini-2.0-flash' is the stable target. I'll stick to 2.0-flash URL but ensure payload is correct.
                // If 400 persists, users might need access to 'gemini-2.0-flash-exp'.
                // Given the user logs showed 'gemini-2.0-flash' with 400, it was likely the responseMimeType causing it.
                // I will try gemini-2.0-flash-exp as it's often more permissive with new modalities.
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${key}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`TTS API Error: ${response.status}`);
                const data = await response.json();

                if (!data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data) {
                    throw new Error("No audio data returned from API");
                }

                const base64Audio = data.candidates[0].content.parts[0].inlineData.data;
                const binaryString = window.atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);

                const wavBuffer = pcmToWav(bytes.buffer);
                const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                return url;
            } catch (error) {
                console.error("TTS Error:", error);
                throw error;
            }
        };

        const callOpenRouter = async (apiKey, model, prompt, systemPrompt, isJson = true) => {
            try {
                const key = apiKey ? apiKey.trim() : "";
                if (!key) throw new Error("OpenRouter API Key is missing. Please add it in Settings.");

                const payload = {
                    model: model || "google/gemini-2.0-flash-001",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: prompt }
                    ],
                    response_format: isJson ? { type: "json_object" } : undefined
                };

                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${key}`,
                        "Content-Type": "application/json",
                        "HTTP-Referer": window.location.href,
                        "X-Title": "EllipsisProse"
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errText = await response.text();
                    try {
                        const errJson = JSON.parse(errText);
                        // Handle specific OpenRouter auth errors more gracefully
                        if (response.status === 401) {
                            throw new Error(`OpenRouter Authorization Failed (401). Please check your API Key in Settings. Details: ${errJson.error?.message || errText}`);
                        }
                        throw new Error(`OpenRouter Error: ${response.status} - ${errJson.error?.message || errText}`);
                    } catch (e) {
                        // If JSON parse fails or it's a different error, throw original text
                        if (e.message.startsWith("OpenRouter")) throw e;
                        throw new Error(`OpenRouter Error: ${response.status} - ${errText}`);
                    }
                }

                const data = await response.json();
                const text = data.choices?.[0]?.message?.content;
                return isJson ? JSON.parse(cleanJson(text)) : text;
            } catch (error) {
                console.error("OpenRouter Error:", error);
                throw error;
            }
        };

        /* ----------------------------------------------------------------------
           RAG & EMBEDDINGS INFRASTRUCTURE
           ----------------------------------------------------------------------
        */

        const cosineSimilarity = (vecA, vecB) => {
            let dotProduct = 0;
            let magnitudeA = 0;
            let magnitudeB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                magnitudeA += vecA[i] * vecA[i];
                magnitudeB += vecB[i] * vecB[i];
            }
            magnitudeA = Math.sqrt(magnitudeA);
            magnitudeB = Math.sqrt(magnitudeB);
            if (magnitudeA === 0 || magnitudeB === 0) return 0;
            return dotProduct / (magnitudeA * magnitudeB);
        };

        class EmbeddingService {
            constructor(apiKey, provider = 'gemini') {
                this.apiKey = apiKey;
                this.provider = provider;
            }

            async getEmbedding(text) {
                if (!text || !text.trim()) return null;
                if (this.provider === 'gemini') {
                    return await this.getGeminiEmbedding(text);
                } else {
                    return await this.getOpenRouterEmbedding(text);
                }
            }

            async getGeminiEmbedding(text) {
                // ... (Existing Gemini Logic)
                const model = "text-embedding-004";
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:embedContent?key=${this.apiKey}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: `models/${model}`,
                        content: { parts: [{ text: text }] }
                    })
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(`Gemini Embedding Failed: ${response.status} - ${err}`);
                }
                const data = await response.json();
                return data.embedding.values;
            }

            async getOpenRouterEmbedding(text) {
                // OpenRouter Embeddings (Standard OpenAI-compatible format)
                // We'll use a widely available model like coverage
                const model = "text-embedding-3-small"; // Or "google/text-embedding-004" if available via OR

                const response = await fetch("https://openrouter.ai/api/v1/embeddings", {
                    method: 'POST',
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "Content-Type": "application/json",
                        "HTTP-Referer": window.location.href,
                        "X-Title": "EllipsisProse"
                    },
                    body: JSON.stringify({
                        model: model,
                        input: text
                    })
                });

                if (!response.ok) {
                    // Fallback mechanism: The user might strictly need a Google key for embeddings if OR ones fail or cost too much.
                    // But for now, let's try to gracefully fail.
                    const err = await response.text();
                    throw new Error(`OpenRouter Embedding Failed: ${response.status} - ${err}`);
                }

                const data = await response.json();
                // Standard OpenAI format: { data: [{ embedding: [...] }] }
                return data.data?.[0]?.embedding;
            }
        }

        class VectorStore {
            constructor(dbName = 'EllipsisVectorStore') {
                this.dbName = dbName;
                this.db = null;
                this.ready = this.init();
            }

            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('vectors')) {
                            db.createObjectStore('vectors', { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async add(id, text, vector, metadata = {}) {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('vectors', 'readwrite');
                    const store = tx.objectStore('vectors');
                    store.put({ id, text, vector, metadata, timestamp: Date.now() });
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }

            async getAll() {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('vectors', 'readonly');
                    const store = tx.objectStore('vectors');
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async search(queryVector, limit = 5, threshold = 0.0, filterFn = null) {
                const allItems = await this.getAll();
                const scored = allItems.map(item => ({
                    ...item,
                    score: cosineSimilarity(queryVector, item.vector)
                }));

                // Filter by threshold AND optional filterFn on metadata
                const filtered = scored.filter(i =>
                    i.score >= threshold && (!filterFn || filterFn(i.metadata))
                );
                filtered.sort((a, b) => b.score - a.score);

                return filtered.slice(0, limit);
            }

            async checkRedundancy(queryVector, threshold = 0.85) {
                // Returns the single highest matching item IF it exceeds threshold
                const results = await this.search(queryVector, 1, threshold);
                return results.length > 0 ? results[0] : null;
            }

            async clear() {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('vectors', 'readwrite');
                    tx.objectStore('vectors').clear();
                    tx.oncomplete = () => resolve();
                });
            }
        }

        class GraphManager {
            constructor() {
                // In-memory graph for now, syncs with React State
                // Nodes are Lore Items (by ID/Topic)
                // Edges are defined in metadata
                this.adjList = new Map();
            }

            buildGraph(loreItems) {
                this.adjList.clear();
                loreItems.forEach(item => {
                    if (!this.adjList.has(item.topic)) {
                        this.adjList.set(item.topic, []);
                    }
                    // Parse "connections" or "related_to" from item details if we add that structure later
                    // For now, we can infer some simple links or explicit ones
                    if (item.related_to) {
                        item.related_to.forEach(rel => {
                            this.adjList.get(item.topic).push(rel);
                            // Undirected?
                            if (!this.adjList.has(rel)) this.adjList.set(rel, []);
                            this.adjList.get(rel).push(item.topic);
                        });
                    }
                });
            }

            getNeighbors(topic) {
                return this.adjList.get(topic) || [];
            }
        }

        /* ----------------------------------------------------------------------
          HELPER COMPONENTS
          ----------------------------------------------------------------------
        */
        const ValenceGraph = ({ dataPoints, height = 60 }) => {
            if (!dataPoints || dataPoints.length < 2) return null;
            const maxVal = 10, minVal = -10, range = 20;
            const stepX = 100 / (dataPoints.length - 1);
            const points = dataPoints.map((val, idx) => {
                const normalizedY = 100 - ((val - minVal) / range) * 100;
                return `${idx * stepX},${normalizedY}`;
            }).join(' ');
            const zeroY = 100 - ((0 - minVal) / range) * 100;
            return (
                <div className="w-full" style={{ height: `${height}px` }}>
                    <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" className="overflow-visible">
                        <line x1="0" y1={zeroY} x2="100" y2={zeroY} stroke="#475569" strokeWidth="1" strokeDasharray="4" />
                        <polyline points={points} fill="none" stroke="#6366f1" strokeWidth="2" vectorEffect="non-scaling-stroke" />
                        {dataPoints.map((val, idx) => {
                            const normalizedY = 100 - ((val - minVal) / range) * 100;
                            const color = val > 0 ? '#10b981' : val < 0 ? '#ef4444' : '#94a3b8';
                            return <circle key={idx} cx={`${idx * stepX}`} cy={normalizedY} r="1.5" fill={color} vectorEffect="non-scaling-stroke" />;
                        })}
                    </svg>
                </div>
            );
        };

        const ValenceBadge = ({ score }) => {
            let color = "bg-slate-700 text-slate-300";
            let IconComp = Minus;
            if (score > 0) { color = "bg-emerald-900/40 text-emerald-400 border-emerald-900/50"; IconComp = TrendingUp; }
            else if (score < 0) { color = "bg-red-900/40 text-red-400 border-red-900/50"; IconComp = TrendingDown; }
            return (
                <div className={`flex items-center gap-1 text-[10px] font-mono px-2 py-0.5 rounded border ${color}`}>
                    <IconComp className="w-3 h-3" /> {score > 0 ? '+' : ''}{score}
                </div>
            );
        };

        const ThreadVisualizer = ({ scenes, threads }) => {
            if (!scenes || !threads || threads.length === 0) return null;

            const laneWidth = 120;
            const rowHeight = 60;
            const svgHeight = (scenes.length + 1) * rowHeight;
            const svgWidth = Math.max(800, threads.length * laneWidth);

            const getThreadX = (index) => index * laneWidth + laneWidth / 2;

            return (
                <div className="overflow-x-auto overflow-y-hidden border border-slate-800 rounded-lg bg-slate-950/30">
                    <svg width={svgWidth} height={svgHeight} className="min-w-full">
                        {/* 1. Draw Thread Lanes (Background) */}
                        {threads.map((t, i) => (
                            <g key={`lane-${t.id}`}>
                                <line
                                    x1={getThreadX(i)} y1={20}
                                    x2={getThreadX(i)} y2={svgHeight}
                                    stroke="#334155" strokeWidth="2" strokeDasharray="4" opacity="0.5"
                                />
                                <text x={getThreadX(i)} y={15} fill="#94a3b8" fontSize="12" textAnchor="middle" fontWeight="bold">
                                    {t.name.length > 15 ? t.name.substring(0, 14) + '...' : t.name}
                                </text>
                            </g>
                        ))}

                        {/* 2. Draw Scene Connections & Knots */}
                        {scenes.map((scene, sceneIdx) => {
                            const y = (sceneIdx + 1) * rowHeight;
                            const activeThreads = threads
                                .map((t, i) => ({ ...t, index: i }))
                                .filter(t => scene.active_thread_ids?.includes(t.id));

                            if (activeThreads.length === 0) return null;

                            // Calculate Interaction Type Styling
                            let interactionColor = "#64748b"; // Isolation (Default)
                            let interactionWidth = 2;

                            if (scene.causality?.interaction_type === "Collision") {
                                interactionColor = "#f43f5e"; // Red
                                interactionWidth = 4;
                            } else if (scene.causality?.interaction_type === "Resonance") {
                                interactionColor = "#3b82f6"; // Blue
                                interactionWidth = 4;
                            } else if (activeThreads.length > 1) {
                                // Fallback if type missing but clearly multiple threads
                                interactionColor = "#a855f7"; // Purple
                            }

                            const minX = Math.min(...activeThreads.map(t => getThreadX(t.index)));
                            const maxX = Math.max(...activeThreads.map(t => getThreadX(t.index)));

                            return (
                                <g key={`scene-row-${sceneIdx}`}>
                                    {/* Connection Line if multiple threads */}
                                    {activeThreads.length > 1 && (
                                        <line
                                            x1={minX} y1={y}
                                            x2={maxX} y2={y}
                                            stroke={interactionColor} strokeWidth={interactionWidth} strokeOpacity="0.8"
                                        />
                                    )}

                                    {/* Nodes */}
                                    {activeThreads.map(t => (
                                        <circle
                                            key={`node-${sceneIdx}-${t.id}`}
                                            cx={getThreadX(t.index)} cy={y} r="6"
                                            fill="#0f172a" stroke={interactionColor} strokeWidth="2"
                                        />
                                    ))}

                                    {/* Label (Scene Title) - positioned near the "center" of the interaction or first thread */}
                                    <text
                                        x={minX + 10} y={y - 12}
                                        fill="#e2e8f0" fontSize="11" fontWeight="500"
                                    >
                                        Sc {scene.number}: {scene.title}
                                    </text>

                                    {/* Interaction Label */}
                                    {scene.causality?.interaction_type && (
                                        <text x={minX + 10} y={y + 16} fill={interactionColor} fontSize="9" fontStyle="italic">
                                            {scene.causality.interaction_type}
                                        </text>
                                    )}
                                </g>
                            );
                        })}
                    </svg>
                </div>
            );
        };

        const CharacterCard = ({ c }) => {
            const [isExpanded, setIsExpanded] = useState(false);
            if (!c) return null;

            return (
                <div className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden">
                    <div className="p-5 border-b border-slate-800 bg-slate-800/30 flex justify-between">
                        <div><h3 className="text-xl font-bold">{c.name}</h3><span className="text-xs text-indigo-400 uppercase font-mono">{c.role}</span></div>
                        <User className="text-slate-600" />
                    </div>
                    <div className="p-5 space-y-4">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="bg-slate-950 p-3 rounded border border-slate-800"><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">Status</div><div className="text-sm whitespace-pre-wrap">{c.details?.story_events || "N/A"}</div></div>
                            <div className="bg-slate-950 p-3 rounded border border-slate-800"><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">Goal</div><div className="text-sm">{c.details?.goals || "Unknown"}</div></div>
                        </div>
                        <div><div className="text-[10px] text-slate-500 font-bold uppercase mb-1">History</div><p className="text-sm text-slate-400">{c.details?.history || "No history."}</p></div>
                        {c.voice_sample && <div className="bg-indigo-900/10 p-3 rounded border border-indigo-500/20 italic text-indigo-200 font-serif">"{c.voice_sample}"</div>}

                        {c.details?.deep_profile && (
                            <div className="pt-4 border-t border-slate-800">
                                <button
                                    onClick={() => setIsExpanded(!isExpanded)}
                                    className="w-full text-xs text-indigo-400 hover:text-indigo-300 flex items-center justify-center gap-2 py-2 bg-slate-950 rounded border border-slate-800 hover:bg-slate-800 transition-colors"
                                >
                                    {isExpanded ? <React.Fragment><Minus size={12} /> Hide Full Interview</React.Fragment> : <React.Fragment><MessageSquare size={12} /> Read Full Interview</React.Fragment>}
                                </button>
                                {isExpanded && (
                                    <div className="mt-4 p-4 bg-slate-950 rounded border border-slate-800 text-sm font-serif leading-relaxed h-96 overflow-y-auto custom-scrollbar whitespace-pre-wrap animate-fade-in">
                                        <div className="text-[10px] text-slate-500 font-sans font-bold uppercase mb-2">Transcript</div>
                                        {c.details.deep_profile}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        /* ----------------------------------------------------------------------
          MAIN APP COMPONENT
          ----------------------------------------------------------------------
        */
        function EllipsisProsef() {
            const [story, setStory] = useState(() => {
                const saved = localStorage.getItem("ellipsisprose_story");
                return saved ? JSON.parse(saved) : {
                    title: "Untitled Story",
                    concept: "",
                    status_quo: "",
                    inciting_incident: "",
                    themes: "",
                    style: { genre: "", mood: "", writing_guide: "" },
                    threads: [],
                    lore: [],
                    cast: [],
                    acts: [],
                    scenes: {},
                    beats: {},
                    prose: {}
                };
            });

            // Settings State
            // Settings State
            const [apiProvider, setApiProvider] = useState(() => localStorage.getItem("ellipsisprose_api_provider") || 'gemini');
            const [embeddingProvider, setEmbeddingProvider] = useState(() => localStorage.getItem("ellipsisprose_embedding_provider") || apiProvider); // New Logic
            const [apiKey, setApiKey] = useState(() => localStorage.getItem("gemini_api_key") || "");
            const [geminiModel, setGeminiModel] = useState(() => localStorage.getItem("ellipsisprose_gemini_model") || "gemini-2.0-flash");
            const [geminiModelsList, setGeminiModelsList] = useState([]);
            const [openRouterKey, setOpenRouterKey] = useState(() => localStorage.getItem("ellipsisprose_openrouter_key") || "");
            const [openRouterModel, setOpenRouterModel] = useState(() => localStorage.getItem("ellipsisprose_openrouter_model") || "google/gemini-2.0-flash-001");
            const [savedModels, setSavedModels] = useState(() => {
                const saved = localStorage.getItem("ellipsisprose_saved_models");
                return saved ? JSON.parse(saved) : ["google/gemini-2.0-flash-001"];
            });

            const [view, setView] = useState(() => localStorage.getItem("ellipsisprose_view") || 'setup');
            const [loading, setLoading] = useState(false);
            const [loadingStep, setLoadingStep] = useState("");
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);

            const [selectedAct, setSelectedAct] = useState(() => {
                const saved = localStorage.getItem("ellipsisprose_selectedAct");
                return saved !== null ? parseInt(saved, 10) : null;
            });

            const [selectedScene, setSelectedScene] = useState(() => {
                const saved = localStorage.getItem("ellipsisprose_selectedScene");
                return saved !== null ? parseInt(saved, 10) : null;
            });

            // TTS State
            const [audioState, setAudioState] = useState({ id: null, status: 'idle', player: null });
            const [audioCache, setAudioCache] = useState({});

            const [inputTitle, setInputTitle] = useState("");
            const [inputConcept, setInputConcept] = useState("");
            const [importedLoreText, setImportedLoreText] = useState(""); // NEW: State for uploaded lore
            const [worldPrimer, setWorldPrimer] = useState(null); // NEW: Distilled world primer
            const loreInputRef = useRef(null); // NEW: Ref for lore file input

            const [promptLog, setPromptLog] = useState([]);
            const fileInputRef = useRef(null);

            // RAG & Graph State
            const vectorStore = useRef(new VectorStore());
            const graphManager = useRef(new GraphManager());
            const embeddingService = useRef(null);
            const [ragStatus, setRagStatus] = useState("idle"); // idle, indexing, ready

            // RAG Inspector State
            const [ragTestQuery, setRagTestQuery] = useState("");
            const [ragTestResults, setRagTestResults] = useState([]);
            const [ragTestLoading, setRagTestLoading] = useState(false);

            // NEW: Distill Lore for large contexts

            // NEW: Distill Lore for large contexts
            const distillLore = async (text) => {
                setLoadingStep("Distilling World Primer...");
                try {
                    const primer = await callAI(
                        `Input Text Length: ${text.length} chars.\n\nText (First 50k chars):\n${text.substring(0, 50000)}...`,
                        PROMPTS.loreDistiller,
                        false, // Text output
                        "Lore Distiller"
                    );
                    setWorldPrimer(primer);
                    return primer;
                } catch (e) {
                    console.error("Distillation failed:", e);
                    showToast("Distillation failed, using raw text.", "error");
                    return null;
                }
            };

            // NEW: Handle Lore File Import
            const handleLoreImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const text = e.target.result;
                    setImportedLoreText(text); // Preserved for UI reference

                    // Reset Primer
                    setWorldPrimer(null);

                    if (text.length > 20000) {
                        showToast("Large file detected. Starting Hybrid Distillation...", "info");
                        setLoading(true);

                        // 1. Distill
                        await distillLore(text);

                        // 2. Chunk & Ingest (Simple chunking)
                        const chunkSize = 2000;
                        const chunks = [];
                        for (let i = 0; i < text.length; i += chunkSize) {
                            chunks.push({
                                topic: `User Upload Segment ${Math.floor(i / chunkSize) + 1}`,
                                detail: text.substring(i, i + chunkSize),
                                valid_from_act: 1,
                                valid_from_scene: 1,
                                related_to: ["Author Upload"],
                                description: "Imported Lore Segment"
                            });
                        }

                        await ingestLoreBatch(chunks);
                        setLoading(false);
                        showToast("Lore distilled and ingested into RAG.", "success");
                    } else {
                        showToast("Lore document loaded!", "success");
                    }
                };
                reader.readAsText(file);
                event.target.value = null; // Reset input
            };

            // ...

            const initStory = async (isAutopilotOrEvent = false) => {
                const isAutopilot = typeof isAutopilotOrEvent === 'boolean' ? isAutopilotOrEvent : false;
                const conceptToUse = inputConcept;
                if (!conceptToUse) return;
                setLoading(true); setLoadingStep("Architecting Story Bible...");

                // Flush Audio Cache
                Object.values(audioCache).forEach(url => URL.revokeObjectURL(url));
                setAudioCache({});
                setAudioState({ id: null, status: 'idle', player: null });

                // Reset selection state
                setSelectedAct(null);
                setSelectedScene(null);

                try {
                    // Inject Imported Lore into the Concept Prompt
                    let finalPrompt = `Concept: ${conceptToUse}`;

                    if (worldPrimer) {
                        // HYBRID STRATEGY: Primer + RAG
                        finalPrompt += `\n\nWORLD PRIMER / CORE RULES:\n${worldPrimer}`;

                        // Fetch specific relevance for the Concept from VectorStore
                        // (Assuming we already ingested chunks in handleLoreImport)
                        const relevantChunks = await retrieveContext(`Concept: ${conceptToUse} Themes and Tone`, 0.6);
                        if (relevantChunks.length > 0) {
                            finalPrompt += `\n\nRELEVANT LORE DETAILS:\n${relevantChunks.map(c => c.text).join('\n')}`;
                        }

                        finalPrompt += `\n\nINSTRUCTION: Incorporate these notes into the Status Quo, Themes, and especially the 'world_lore' array. The World Primer defines the hard rules; the Details provide color.`;

                    } else if (importedLoreText && importedLoreText.trim().length > 0) {
                        // LEGACY/SMALL FILE STRATEGY: Direct Injection
                        finalPrompt += `\n\nEXISTING WORLD LORE / AUTHOR NOTES:\n${importedLoreText}\n\nINSTRUCTION: Incorporate these notes into the Status Quo, Themes, and especially the 'world_lore' array. Ensure consistency with these established facts.`;
                    }

                    const bible = await callAI(finalPrompt, PROMPTS.storyArchitect, true, "Story Architect");

                    // 1. Identify All Characters
                    setLoadingStep("Identifying Cast...");
                    const extractionPrompt = `Analyze this Story Bible and list all characters mentioned.\n\n${JSON.stringify(bible)}`;
                    const extracted = await callAI(extractionPrompt, PROMPTS.characterExtractor, true, "Cast Scanner");

                    // 2. Prepare Cast List (Merge Protagonist + Extracted)
                    let finalCast = [bible.protagonist];

                    if (extracted.characters) {
                        extracted.characters.forEach(c => {
                            // If not already in list (check by name, loosely)
                            if (!finalCast.find(existing => existing.name.toLowerCase() === c.name.toLowerCase())) {
                                finalCast.push({
                                    name: c.name,
                                    role: c.role,
                                    voice_sample: "TBD", // Will be profiled
                                    details: {
                                        history: c.context || c.description,
                                        story_events: "Identified in Story Bible",
                                        goals: c.goals || "Unknown (To be revealed)",
                                        deep_profile: null
                                    }
                                });
                            }
                        });
                    }

                    // 3. Generate Deep Profiles for EVERYONE
                    setLoadingStep("Interviewing Cast...");
                    for (let i = 0; i < finalCast.length; i++) {
                        // Autopilot optimization: only profile protagonist deep initially if in hurry? 
                        // No, let's keep it robust.
                        const char = finalCast[i];
                        if (!char.details?.deep_profile) {
                            setLoadingStep(`Interviewing ${char.name}...`);
                            const context = `Role: ${char.role}\nDescription: ${char.details?.history || char.details?.story_events}\nGoal: ${char.details?.goals}`;

                            // Pass bible context
                            const storyContext = {
                                concept: bible.concept,
                                themes: bible.themes,
                                style: bible.style
                            };

                            const profile = await generateCharacterProfile(char.name, char.role, context, storyContext);
                            if (!char.details) char.details = {};
                            char.details.deep_profile = profile;
                            // Also set voice_sample to a snippet if "TBD"
                            if (char.voice_sample === "TBD") {
                                char.voice_sample = profile.split('.')[0].substring(0, 50) + "...";
                            }
                        }
                    }

                    // Reset story state completely
                    const newStory = {
                        title: inputTitle || "My New Story",
                        concept: bible.concept,
                        status_quo: bible.status_quo,
                        inciting_incident: bible.inciting_incident,
                        themes: bible.themes,
                        style: bible.style,
                        threads: bible.threads,
                        cast: finalCast,
                        lore: bible.world_lore,
                        acts: [],
                        scenes: {},
                        beats: {},
                        prose: {}
                    };

                    setLoadingStep("Structuring Acts...");
                    const actData = await callAI(`Concept: ${bible.concept}\nThreads: ${JSON.stringify(bible.threads)}`, PROMPTS.actStructure, true, "Act Structure");

                    // 4. Schedule Lore (Avoid Spoilers)
                    setLoadingStep("Scheduling Lore Reveals...");
                    const schedPrompt = `Story Concept: ${bible.concept}\n\nAct Outline: ${JSON.stringify(actData.acts)}\n\nWorld Lore: ${JSON.stringify(bible.world_lore)}`;
                    const loreSchedule = await callAI(schedPrompt, PROMPTS.loreScheduler, true, "Lore Scheduler");

                    // Merge schedule into lore
                    const scheduledLore = bible.world_lore.map(l => {
                        const sched = loreSchedule.lore_schedule?.find(s => s.topic === l.topic);
                        return {
                            ...l,
                            valid_from_act: sched?.valid_from_act || 1,
                            valid_from_scene: sched?.valid_from_scene || 1
                        };
                    });

                    // RAG: Ingest Initial Batch
                    setLoadingStep("Indexing Lore (RAG)...");
                    // Note: We use the scheduledLore but ingestLoreBatch might mutate or we just index them
                    await ingestLoreBatch(scheduledLore);
                    // We could update story.lore with the result of ingestLoreBatch if we want to capture merged IDs 
                    // but for init, they should be unique mostly.

                    const finalStory = { ...newStory, lore: scheduledLore, acts: actData.acts };
                    setStory(finalStory);
                    setView('dashboard'); // Go to dashboard
                    showToast("Story Bible initialized (with RAG)!");
                    return finalStory;
                } catch (e) {
                    console.error(e);
                    alert("Initialization failed: " + e.message);
                } finally {
                    if (!isAutopilot) setLoading(false);
                }
            };



            // Single Item Ingest with Redundancy Check
            const ingestLore = async (item) => {
                if (!item.topic || !item.detail) return { ...item, is_merged: false };

                // 1. Check for Semantic Redundancy
                const tempEmbedding = await embeddingService.current.getEmbedding(`${item.topic}: ${item.description || item.detail}`);
                if (!tempEmbedding) return item;

                const redundancy = await vectorStore.current.checkRedundancy(tempEmbedding, 0.85);

                if (redundancy) {
                    // MERGE
                    const mergedDetail = await callAI(
                        `Existing: ${redundancy.text}\nNew: ${item.detail}\n\nTask: Merge these two lore entries into one concise, consistent entry.`,
                        "You are a Lore Keeper.",
                        false, // Text output
                        "Lore Merger"
                    );

                    // Update Vector Store
                    const newEmbedding = await embeddingService.current.getEmbedding(`${item.topic}: ${mergedDetail}`);
                    await vectorStore.current.add(redundancy.id, `${item.topic}: ${mergedDetail}`, newEmbedding, { ...redundancy.metadata, detail: mergedDetail });

                    return { ...item, detail: mergedDetail, is_merged: true };
                } else {
                    // NEW ENTRY
                    const id = `lore_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    await vectorStore.current.add(id, `${item.topic}: ${item.detail}`, tempEmbedding, { topic: item.topic, valid_from_act: item.valid_from_act, valid_from_scene: item.valid_from_scene, related_to: item.related_to });
                    return { ...item, is_merged: false };
                }
            };

            // Batch Ingest (for Init or Import)
            const ingestLoreBatch = async (loreList) => {
                setRagStatus("indexing_batch");
                // Clear old store if re-initializing? Maybe not if we want persistence, but for now yes to avoid stale ghosts
                await vectorStore.current.clear();

                let processedList = [];
                for (const item of loreList) {
                    // We run sequentially to allow deduplication against items just added in this batch
                    const processed = await ingestLore(item);
                    if (!processed.is_merged) {
                        processedList.push(processed);
                    } else {
                        // If merged, we update the existing item in the processedList
                        const idx = processedList.findIndex(p => p.topic === processed.topic);
                        if (idx !== -1) processedList[idx] = processed;
                    }
                }
                setRagStatus("ready");
                return processedList;
            };

            // Build Graph on Load/Change
            useEffect(() => {
                if (story.lore) {
                    graphManager.current.buildGraph(story.lore);
                }
            }, [story.lore]);

            // UI State
            const [collapsedActs, setCollapsedActs] = useState({});
            const [collapsedProse, setCollapsedProse] = useState({});
            const [toast, setToast] = useState(null); // { message, type: 'success'|'error' }

            const showToast = (message, type = 'success') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };

            const toggleAct = (idx) => {
                setCollapsedActs(prev => ({ ...prev, [idx]: !prev[idx] }));
            };

            const toggleProse = (bId) => {
                setCollapsedProse(prev => ({ ...prev, [bId]: !prev[bId] }));
            };

            const getSceneColor = (actIdx, sceneIdx) => {
                const sId = `${actIdx}-${sceneIdx}`;
                const beats = story.beats[sId];
                if (!beats || beats.length === 0) return '';

                // Check prose status
                let writtenCount = 0;
                beats.forEach((b, i) => {
                    if (story.prose[`${sId}-${i}`]?.final) writtenCount++;
                });

                if (writtenCount === beats.length) return 'text-emerald-400';
                if (writtenCount > 0) return 'text-amber-400';
                return '';
            };

            // Persistence Effects
            useEffect(() => { localStorage.setItem("ellipsisprose_api_provider", apiProvider); }, [apiProvider]);
            useEffect(() => { localStorage.setItem("gemini_api_key", apiKey); }, [apiKey]);
            useEffect(() => { localStorage.setItem("ellipsisprose_gemini_model", geminiModel); }, [geminiModel]);
            useEffect(() => { localStorage.setItem("ellipsisprose_openrouter_key", openRouterKey); }, [openRouterKey]);
            useEffect(() => { localStorage.setItem("ellipsisprose_openrouter_model", openRouterModel); }, [openRouterModel]);
            useEffect(() => { localStorage.setItem("ellipsisprose_saved_models", JSON.stringify(savedModels)); }, [savedModels]);

            useEffect(() => {
                localStorage.setItem("ellipsisprose_story", JSON.stringify(story));
            }, [story]);

            // Instantiate/Update Embedding Service
            useEffect(() => {
                const key = embeddingProvider === 'gemini' ? apiKey : openRouterKey;
                embeddingService.current = new EmbeddingService(key, embeddingProvider);
            }, [apiKey, openRouterKey, embeddingProvider]);

            useEffect(() => {
                localStorage.setItem("ellipsisprose_view", view);
            }, [view]);

            useEffect(() => {
                if (selectedAct !== null) localStorage.setItem("ellipsisprose_selectedAct", selectedAct);
                else localStorage.removeItem("ellipsisprose_selectedAct");
            }, [selectedAct]);

            useEffect(() => {
                if (selectedScene !== null) localStorage.setItem("ellipsisprose_selectedScene", selectedScene);
                else localStorage.removeItem("ellipsisprose_selectedScene");
            }, [selectedScene]);



            const handlePlayTTS = async (id, text) => {
                // 1. If currently playing THIS track, stop it
                if (audioState.id === id && audioState.status === 'playing') {
                    audioState.player.pause();
                    audioState.player.currentTime = 0;
                    setAudioState({ id: null, status: 'idle', player: null });
                    return;
                }

                // 2. If playing ANOTHER track, stop it first
                if (audioState.player) {
                    audioState.player.pause();
                    audioState.player.currentTime = 0;
                    // We don't return here, we proceed to play the new one
                }

                // 3. CHECK CACHE
                if (audioCache[id]) {
                    // Play from cache
                    try {
                        const audio = new Audio(audioCache[id]);
                        audio.onended = () => setAudioState({ id: null, status: 'idle', player: null });

                        setAudioState({ id, status: 'playing', player: audio });

                        await audio.play();
                    } catch (e) {
                        console.error("Playback failed:", e);
                        setAudioState({ id: null, status: 'idle', player: null });
                        alert("Playback failed. Please try again.");
                    }
                    return;
                }

                // 4. GENERATE NEW
                setAudioState({ id, status: 'loading', player: null });

                try {
                    const url = await callTTS(apiKey, text);
                    setAudioCache(prev => ({ ...prev, [id]: url }));
                    // We do NOT auto-play here to avoid iOS issues. 
                    // User sees Play button -> clicks it -> plays from cache (Step 3).
                    setAudioState({ id: null, status: 'idle', player: null });
                } catch (e) {
                    alert("TTS Failed: " + e.message);
                    setAudioState({ id: null, status: 'idle', player: null });
                }
            };

            const handleWorldUpdates = async (updates, activeActNum = 1, activeSceneNum = 1) => {
                if (!updates) return;

                // RAG: Pre-process Lore Updates (Async Ingestion + Deduplication)
                if (updates.lore_updates && updates.lore_updates.length > 0) {
                    setRagStatus("indexing");
                    const processedLoreStart = [];
                    for (const up of updates.lore_updates) {
                        const rawItem = {
                            topic: up.topic,
                            detail: up.detail,
                            valid_from_act: activeActNum,
                            valid_from_scene: activeSceneNum
                        };
                        // This awaits the embedding call and redundancy check
                        const processed = await ingestLore(rawItem);
                        processedLoreStart.push(processed);
                    }
                    setRagStatus("idle");

                    // Now Update React State with processed items
                    setStory(prev => {
                        let newCast = [...prev.cast];
                        // Logic for Cast (same as before)
                        if (updates.cast_updates) {
                            updates.cast_updates.forEach(up => {
                                const idx = newCast.findIndex(c => c.name === up.name);
                                if (idx !== -1) {
                                    const char = newCast[idx];
                                    if (!char.details) char.details = { history: "", story_events: "", goals: "", evolution: "" };
                                    if (up.append_history) char.details.history += `\n[New]: ${up.append_history}`;
                                    if (up.append_story_events) char.details.story_events += `\n- ${up.append_story_events}`;
                                    if (up.update_goals) char.details.goals = up.update_goals;
                                    newCast[idx] = char;
                                }
                            });
                        }
                        if (updates.new_characters) {
                            updates.new_characters.forEach(nc => {
                                if (!newCast.find(c => c.name === nc.name)) newCast.push(nc);
                            });
                        }

                        let newLore = [...prev.lore];
                        processedLoreStart.forEach(pItem => {
                            if (pItem.is_merged) {
                                // Update existing item in State
                                const idx = newLore.findIndex(l => l.topic === pItem.topic);
                                if (idx !== -1) {
                                    newLore[idx] = { ...newLore[idx], detail: pItem.detail };
                                }
                            } else {
                                // Add new
                                if (!newLore.find(l => l.topic === pItem.topic)) {
                                    newLore.push(pItem);
                                }
                            }
                        });

                        return { ...prev, cast: newCast, lore: newLore };
                    });

                } else {
                    // No lore updates, just cast (Synchronous fallback)
                    setStory(prev => {
                        let newCast = [...prev.cast];
                        if (updates.cast_updates) {
                            updates.cast_updates.forEach(up => {
                                const idx = newCast.findIndex(c => c.name === up.name);
                                if (idx !== -1) {
                                    const char = newCast[idx];
                                    if (!char.details) char.details = { history: "", story_events: "", goals: "", evolution: "" };
                                    if (up.append_history) char.details.history += `\n[New]: ${up.append_history}`;
                                    if (up.append_story_events) char.details.story_events += `\n- ${up.append_story_events}`;
                                    if (up.update_goals) char.details.goals = up.update_goals;
                                    newCast[idx] = char;
                                }
                            });
                        }
                        if (updates.new_characters) {
                            updates.new_characters.forEach(nc => {
                                if (!newCast.find(c => c.name === nc.name)) newCast.push(nc);
                            });
                        }
                        return { ...prev, cast: newCast };
                    });
                }
            };

            const handleDeleteLore = (index) => {
                if (window.confirm("Are you sure you want to delete this lore item?")) {
                    setStory(prev => {
                        const newLore = [...prev.lore];
                        newLore.splice(index, 1);
                        return { ...prev, lore: newLore };
                    });
                }
            };

            const handleExport = () => {
                try {
                    const jsonString = JSON.stringify(story, null, 2);
                    const blob = new Blob([jsonString], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `ellipsisprose_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (err) { alert("Export failed: " + err.message); }
            };

            const handleExportEpub = async () => {
                if (!window.JSZip) {
                    alert("JSZip library not loaded. Please restart the app or check your internet connection.");
                    return;
                }

                try {
                    const zip = new JSZip();
                    const cleanTitle = story.title ? story.title : "My Story";
                    const safeFilename = cleanTitle.replace(/[^a-zA-Z0-9]/g, "_");

                    // 1. Mimetype (must be first, no compression)
                    zip.file("mimetype", "application/epub+zip", { compression: "STORE" });

                    // 2. Container
                    zip.folder("META-INF").file("container.xml", `<?xml version="1.0" ?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
   <rootfiles>
      <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
   </rootfiles>
</container>`);

                    const oebps = zip.folder("OEBPS");
                    const textFolder = oebps.folder("Text");

                    let manifestItems = [];
                    let spineItems = [];
                    let tocPoints = [];
                    let playOrder = 1;

                    // Helper for valid IDs
                    const cleanId = (str) => str.replace(/[^a-zA-Z0-9]/g, "_");

                    // 3. Title Page
                    const titleFilename = "Title.xhtml";
                    const titleHtml = `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Title Page</title>
<style>body { text-align: center; margin-top: 30%; }</style></head>
<body>
<h1>${story.title ? story.title.replace(/&/g, "&amp;") : "Untitled Story"}</h1>
<h3 style="font-weight: normal; font-style: italic;">${story.concept ? story.concept.replace(/&/g, "&amp;") : "My Story"}</h3>
<h3>Drafted with EllipsisProse</h3>
</body>
</html>`;
                    textFolder.file(titleFilename, titleHtml);
                    manifestItems.push(`<item id="titlepage" href="Text/${titleFilename}" media-type="application/xhtml+xml"/>`);
                    spineItems.push(`<itemref idref="titlepage"/>`);
                    tocPoints.push(`<navPoint id="navPoint-0" playOrder="0"><navLabel><text>Title Page</text></navLabel><content src="Text/${titleFilename}"/></navPoint>`);

                    // 4. Content (Acts and Scenes)
                    story.acts.forEach((act, actIdx) => {
                        const actScenes = story.scenes[actIdx];
                        if (!actScenes || actScenes.length === 0) return;

                        // Act divider
                        const actFilename = `Act_${actIdx + 1}.xhtml`;
                        const actHtml = `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>${act.title}</title>
<style>body { text-align: center; margin-top: 30%; }</style></head>
<body>
<h1>ACT ${act.number}</h1>
<h2>${act.title.replace(/&/g, "&amp;")}</h2>
<p>${act.description.replace(/&/g, "&amp;")}</p>
</body>
</html>`;
                        textFolder.file(actFilename, actHtml);
                        const actId = `act_${actIdx + 1}`;
                        manifestItems.push(`<item id="${actId}" href="Text/${actFilename}" media-type="application/xhtml+xml"/>`);
                        spineItems.push(`<itemref idref="${actId}"/>`);

                        // Act NavPoint START
                        let actNavPoint = `<navPoint id="navPoint-${playOrder}" playOrder="${playOrder}">
<navLabel><text>Act ${act.number}: ${act.title.replace(/&/g, "&amp;")}</text></navLabel>
<content src="Text/${actFilename}"/>`;
                        playOrder++;

                        actScenes.forEach((scene, sceneIdx) => {
                            const sId = `${actIdx}-${sceneIdx}`;
                            const beats = story.beats[sId];

                            // Build Scene Content
                            let sceneBody = `<h1>Chapter ${scene.number}: ${scene.title.replace(/&/g, "&amp;")}</h1>`;

                            if (beats && beats.length > 0) {
                                beats.forEach((b, bi) => {
                                    const prose = story.prose[`${sId}-${bi}`];
                                    if (prose && prose.final) {
                                        // Ensure Markdown parsing results in valid XML content if possible
                                        // Simple regex cleanup for unclosed tags could be complex, but let's assume standard prose
                                        let html = parseMarkdown(prose.final);
                                        // Remove <br> for <br /> compliance if needed, though parseMarkdown generates <br />
                                        sceneBody += `\n<div class="beat">\n${html}\n</div>\n<hr style="border: 0; border-top: 1px solid #ccc; margin: 2em auto; width: 50%;" />\n`;
                                    }
                                });
                            } else {
                                sceneBody += `<p><em>[Scene not yet written]</em></p>`;
                            }

                            // Remove last HR
                            sceneBody = sceneBody.replace(/<hr [^>]*\/>\s*$/, "");

                            const sceneFilename = `Act${act.number}_Scene${scene.number}.xhtml`;
                            const sceneHtml = `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>${scene.title.replace(/&/g, "&amp;")}</title>
<style>
body { font-family: sans-serif; line-height: 1.6; padding: 1em; }
p { margin-bottom: 1em; text-indent: 0; }
.beat p { text-indent: 1.5em; }
h1 { text-align: center; margin-bottom: 2em; }
</style>
</head>
<body>
${sceneBody}
</body>
</html>`;
                            textFolder.file(sceneFilename, sceneHtml);
                            const sceneId = `scene_${actIdx}_${sceneIdx}`;
                            manifestItems.push(`<item id="${sceneId}" href="Text/${sceneFilename}" media-type="application/xhtml+xml"/>`);
                            spineItems.push(`<itemref idref="${sceneId}"/>`);

                            // Add Scene to NavMap (Nested)
                            actNavPoint += `
<navPoint id="navPoint-${playOrder}" playOrder="${playOrder}">
<navLabel><text>${scene.number}. ${scene.title.replace(/&/g, "&amp;")}</text></navLabel>
<content src="Text/${sceneFilename}"/>
</navPoint>`;
                            playOrder++;
                        });

                        // Act NavPoint END
                        actNavPoint += `</navPoint>`;
                        tocPoints.push(actNavPoint);
                    });

                    // 5. NCX (TOC)
                    const ncx = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
   <head>
      <meta name="dtb:uid" content="urn:uuid:12345"/>
      <meta name="dtb:depth" content="2"/>
      <meta name="dtb:totalPageCount" content="0"/>
      <meta name="dtb:maxPageNumber" content="0"/>
   </head>
   <docTitle><text>${story.title ? story.title.replace(/&/g, "&amp;") : "Untitled Story"}</text></docTitle>
   <navMap>
      ${tocPoints.join('\n')}
   </navMap>
</ncx>`;
                    oebps.file("toc.ncx", ncx);

                    // 6. OPF
                    const opf = `<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
   <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
      <dc:title>${story.title ? story.title.replace(/&/g, "&amp;") : "Untitled Story"}</dc:title>
      <dc:creator opf:role="aut">EllipsisProse User</dc:creator>
      <dc:language>en</dc:language>
      <dc:identifier id="BookId" opf:scheme="UUID">urn:uuid:12345</dc:identifier>
   </metadata>
   <manifest>
      <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
      ${manifestItems.join('\n      ')}
   </manifest>
   <spine toc="ncx">
      ${spineItems.join('\n      ')}
   </spine>
</package>`;
                    oebps.file("content.opf", opf);

                    // 7. Generate
                    const content = await zip.generateAsync({ type: "blob" });
                    const url = URL.createObjectURL(content);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `ellipsisprose_export_${safeFilename}_${new Date().toISOString().slice(0, 10)}.epub`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                } catch (e) {
                    console.error(e);
                    alert("EPUB Generation failed: " + e.message);
                }
            };

            const handleImport = (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (imported.concept && Array.isArray(imported.acts)) {
                            setStory(imported); setView('dashboard'); alert("Loaded!");
                        } else { alert("Invalid file format."); }
                    } catch (error) { alert("Error: " + error.message); }
                };
                reader.readAsText(file);
                event.target.value = null;
            };

            // RAG Retrieval Engine
            const retrieveContext = async (query, threshold = 0.5, filterFn = null) => {
                if (!embeddingService.current || !vectorStore.current) return [];

                try {
                    // 0. Query Expansion (Agentic Step)
                    // We only do this for purely narrative queries, not system queries like "Concept..."
                    let searchKey = query;
                    if (!query.startsWith("Concept:")) {
                        try {
                            const expanded = await callAI(
                                `Identify key entities, locations, and implicit relationships in this narrative action. Output a comma-separated list of keywords.\nInput: "${query}"`,
                                "You are a Search Optimizer.",
                                false,
                                "Query Expansion"
                            );
                            if (expanded) searchKey = `${query} ${expanded}`;
                        } catch (e) {
                            // Fallback to raw query if expansion fails
                            console.warn("Query expansion failed, using raw query.");
                        }
                    }

                    const queryVector = await embeddingService.current.getEmbedding(searchKey);
                    if (!queryVector) return [];

                    // 1. Vector Search (Top 3) with Filter
                    const results = await vectorStore.current.search(queryVector, 3, threshold, filterFn);

                    // 2. Graph Traversal (Immediate Neighbors of Top Results)
                    let augmentedResults = [...results];
                    const processedTopics = new Set(results.map(r => r.metadata.topic));

                    for (const res of results) {
                        const neighbors = graphManager.current.getNeighbors(res.metadata.topic);
                        for (const neighborTopic of neighbors) {
                            if (!processedTopics.has(neighborTopic)) {
                                // We found a neighbor. We need its content. 
                                // Since VectorStore currently stores by ID primarily, we might need to scan or keep a topic-map.
                                // Optimization: For now, we search memory 'story.lore' as fallback or query DB by topic index if strict.
                                // Simple approach: Check In-Memory Story.Lore for content
                                const neighborItem = story.lore.find(l => l.topic === neighborTopic);
                                if (neighborItem) {
                                    augmentedResults.push({
                                        text: `${neighborItem.topic}: ${neighborItem.detail}`,
                                        score: 1.0, // High relevance by relation
                                        metadata: { topic: neighborItem.topic, relation: "Graph Neighbor of " + res.metadata.topic }
                                    });
                                    processedTopics.add(neighborTopic);
                                }
                            }
                        }
                    }

                    return augmentedResults;
                } catch (e) {
                    console.error("Retrieval failed:", e);
                    return [];
                }
            };

            // RAG Inspector Handler
            const handleRagTest = async () => {
                if (!ragTestQuery.trim()) return;
                setRagTestLoading(true);
                try {
                    // Test retrieval NO FILTER
                    const results = await retrieveContext(ragTestQuery, 0.0); // 0.0 threshold to see everything
                    setRagTestResults(results);
                } catch (e) {
                    alert("RAG Test Failed: " + e.message);
                } finally {
                    setRagTestLoading(false);
                }
            };

            const callAI = async (prompt, systemPrompt, isJson = true, logName = "AI Task") => {
                const logEntry = {
                    id: Date.now(),
                    timestamp: new Date().toLocaleTimeString(),
                    function: logName,
                    prompt: prompt,
                    systemPrompt: systemPrompt
                };
                setPromptLog(prev => [logEntry, ...prev]);

                const maxRetries = 3;
                let attempt = 0;

                while (attempt < maxRetries) {
                    try {
                        if (apiProvider === 'gemini') {
                            return await callGemini(apiKey, geminiModel, prompt, systemPrompt, isJson);
                        } else {
                            return await callOpenRouter(openRouterKey, openRouterModel, prompt, systemPrompt, isJson);
                        }
                    } catch (error) {
                        attempt++;
                        const is503 = error.message.includes("503") || error.message.includes("Service Unavailable") || error.message.includes("Overloaded");

                        if (is503 && attempt < maxRetries) {
                            console.warn(`API 503 Error. Retrying in 5 seconds... (Attempt ${attempt}/${maxRetries})`);
                            showToast(`API Busy (503). Retrying step... (${attempt}/${maxRetries})`, 'error');
                            await new Promise(resolve => setTimeout(resolve, 5000));
                        } else {
                            throw error;
                        }
                    }
                }
            };

            const generateCharacterProfile = async (charName, charRole, context, storyContext) => {
                const contextBlock = `
STORY CONCEPT: ${storyContext?.concept || "Standard Narrative"}
THEMES: ${storyContext?.themes || "General"}
STYLE/TONE: ${JSON.stringify(storyContext?.style || {})}
CHARACTER CONTEXT: ${context}
`;
                const prompt = `${contextBlock}\n\nInterviewer: "Tell me about yourself. Who are you really, ${charName}?" We know you're ${charRole}`;
                return await callAI(prompt, PROMPTS.characterGenerator, false, "Character Profiler");
            };

            const getCharacterDetails = async (charName, mutableCastList) => {
                const charIdx = mutableCastList.findIndex(c => c.name === charName);
                if (charIdx === -1) {
                    console.log(`Character ${charName} not found in cast.`);
                    return "Character details unavailable.";
                }
                const char = mutableCastList[charIdx];
                if (char.details?.deep_profile) return char.details.deep_profile;

                setLoadingStep(`Interviewing ${char.name}...`);
                const context = `Goals: ${char.details?.goals}, History: ${char.details?.history}, Events: ${char.details?.story_events}`;

                // Pass story context (concept, themes, style)
                const storyContext = {
                    concept: story.concept,
                    themes: story.themes,
                    style: story.style
                };

                const profile = await generateCharacterProfile(char.name, char.role, context, storyContext);

                if (!mutableCastList[charIdx].details) mutableCastList[charIdx].details = {};
                mutableCastList[charIdx].details.deep_profile = profile;
                return profile;
            };

            const isSceneComplete = (actIdx, sceneIdx) => {
                const sId = `${actIdx}-${sceneIdx}`;
                const beats = story.beats[sId];
                if (!beats || beats.length === 0) return false;
                // Check if ALL beats have final prose
                return beats.every((b, i) => story.prose[`${sId}-${i}`]?.final);
            };

            const handleBeatChange = (actIdx, sceneIdx, beatIdx, newText) => {
                const sId = `${actIdx}-${sceneIdx}`;
                setStory(prev => {
                    const newBeats = [...prev.beats[sId]];
                    newBeats[beatIdx] = { ...newBeats[beatIdx], description: newText };
                    return {
                        ...prev,
                        beats: {
                            ...prev.beats,
                            [sId]: newBeats
                        }
                    };
                });
            };

            const handleBeatPacingChange = (actIdx, sceneIdx, beatIdx, newPacing) => {
                const sId = `${actIdx}-${sceneIdx}`;
                setStory(prev => {
                    const newBeats = [...prev.beats[sId]];
                    newBeats[beatIdx] = { ...newBeats[beatIdx], pacing: newPacing };
                    return {
                        ...prev,
                        beats: {
                            ...prev.beats,
                            [sId]: newBeats
                        }
                    };
                });
            };

            const requestSceneWeaving = (actIdx) => {
                if (story.scenes[actIdx]?.length > 0) {
                    if (!window.confirm("WARNING: Rerunning the Scene Weaver will overwrite ALL existing scenes and beats for this Act. This cannot be undone. Are you sure?")) return;
                }
                generateScenes(actIdx);
            };

            const requestBeatGeneration = (actIdx, sceneIdx) => {
                const sId = `${actIdx}-${sceneIdx}`;
                if (story.beats[sId]?.length > 0) {
                    if (!window.confirm("WARNING: Rerunning the Beat Director will overwrite ALL existing beats and prose for this scene. This cannot be undone. Are you sure?")) return;
                }
                generateBeats(actIdx, sceneIdx);
            };

            const generateScenes = async (actIndex, currentStory = story, isAutopilot = false) => {
                const storyToUse = currentStory || story;
                setLoading(true); setLoadingStep(`Weaving Scenes for Act ${actIndex + 1}...`);
                try {
                    const act = storyToUse.acts[actIndex];
                    const actNumber = act.number || actIndex + 1;

                    if (!isAutopilot && storyToUse.scenes[actIndex]?.length > 0) {
                        // This check is redundant with requestSceneWeaving but kept for safety if called directly
                    }

                    let systemPrompt = PROMPTS.sceneWeaverAct1;
                    if (actNumber === 2) systemPrompt = PROMPTS.sceneWeaverAct2;
                    if (actNumber >= 3) systemPrompt = PROMPTS.sceneWeaverAct3;

                    let previousEventsContext = "";
                    if (actIndex > 0) {
                        const prevActScenes = storyToUse.scenes[actIndex - 1];
                        if (prevActScenes && prevActScenes.length > 0) {
                            const lastScenes = prevActScenes.slice(-2);
                            previousEventsContext = `\n\nEVENTS IMMEDIATELY PRECEDING THIS ACT (continuity context):\n${lastScenes.map(s => `[PREVIOUS SCENE ${s.number}]: ${s.title}\n${s.description}`).join('\n\n')}`;
                        }
                    }

                    // RAG: Retrieve Relevant Context for the Act
                    const query = `Act ${act.number}: ${act.title}. ${act.description}. Themes: ${storyToUse.themes}`;
                    // Query + Act Filter (Spoiler Protection)
                    const ragLoreDocs = await retrieveContext(query, 0.6, (meta) => {
                        return !meta.valid_from_act || meta.valid_from_act <= actNumber;
                    });
                    const ragContext = ragLoreDocs.length > 0
                        ? `\nRELEVANT WORLD LORE (RAG Retrieved):\n${ragLoreDocs.map(d => `- [${d.metadata.topic}]: ${d.text} (${d.metadata.relation || "Direct Match"})`).join('\n')}`
                        : `\nWORLD LORE:\n${JSON.stringify(storyToUse.lore)}`; // Fallback if RAG fails or empty

                    const res = await callAI(`Act Context: ${JSON.stringify(act)}\nThreads: ${JSON.stringify(storyToUse.threads)}\nCast: ${JSON.stringify(storyToUse.cast)}\n${ragContext}${previousEventsContext}`, systemPrompt, true, "Scene Weaver");

                    const nextStory = { ...storyToUse, scenes: { ...storyToUse.scenes, [actIndex]: res.scenes } };

                    setStory(nextStory);

                    // Handle world updates logic but return nextStory
                    // handleWorldUpdates calls setStory internally, which we can't chain easily without refactoring handleWorldUpdates.
                    // For now, let's manually replicate the update logic for the return object

                    let finalStory = nextStory;
                    if (res.new_characters) {
                        // We just merge them into cast if unique
                        const newCast = [...finalStory.cast];
                        res.new_characters.forEach(nc => {
                            if (!newCast.find(c => c.name === nc.name)) newCast.push(nc);
                        });
                        finalStory = { ...finalStory, cast: newCast };
                        setStory(finalStory);
                    }

                    setSelectedAct(actIndex);
                    showToast(`Scenes for Act ${actNumber} generated!`);
                    return finalStory;
                } catch (e) { alert(e.message); throw e; } finally { if (!isAutopilot) setLoading(false); }
            };

            const generateBeats = async (actIdx, sceneIdx, currentStory = story, isAutopilot = false) => {
                const storyToUse = currentStory || story;
                const sId = `${actIdx}-${sceneIdx}`;
                const sceneData = storyToUse.scenes[actIdx][sceneIdx];
                const activeThreads = sceneData.active_thread_ids;

                setLoading(true);

                // 1. Clear State First (Clean Slate) - Reflect in Next State
                setLoadingStep("Directing Beats...");
                // Note: We skip the intermediate "clearing" setStory for autopilot to save renders, 
                // effectively just overwriting.

                try {
                    // Hydrate thread objects for context
                    const activeThreadsData = storyToUse.threads.filter(t => activeThreads.includes(t.id));

                    // RAG: Retrieval for Scene Context
                    const query = `Scene: ${sceneData.title}. Location: ${sceneData.location}. Characters: ${sceneData.cast_names.join(", ")}. Threads: ${activeThreadsData.map(t => t.name).join(", ")}`;
                    // Query + Scene Filter (Spoiler Protection)
                    const ragLoreDocs = await retrieveContext(query, 0.65, (meta) => {
                        return !meta.valid_from_act || meta.valid_from_act <= (actIdx + 1);
                    });
                    const ragContext = ragLoreDocs.length > 0
                        ? `\nRELEVANT WORLD LORE (RAG Retrieved):\n${ragLoreDocs.map(d => `- [${d.metadata.topic}]: ${d.text}`).join('\n')}`
                        : `\nWORLD LORE:\n${JSON.stringify(storyToUse.lore)}`;

                    const res = await callAI(`Scene: ${JSON.stringify(sceneData)}\nThreads: ${JSON.stringify(activeThreadsData)}\n${ragContext}`, PROMPTS.beatDirector, true, "Beat Director");

                    if (res && res.beats) {
                        const nextStory = {
                            ...storyToUse,
                            beats: { ...storyToUse.beats, [sId]: res.beats },
                            // clear prose for this scene to be safe
                            prose: Object.keys(storyToUse.prose).reduce((acc, key) => {
                                if (!key.startsWith(`${sId}-`)) acc[key] = storyToUse.prose[key];
                                return acc;
                            }, {})
                        };
                        setStory(nextStory); // Update UI
                        setSelectedScene(sceneIdx);
                        showToast("Beats generated successfully!");
                        return nextStory;
                    } else {
                        throw new Error("No beats generated from AI response.");
                    }
                } catch (e) {
                    // alert("Beat Generation Error: " + e.message);
                    console.error(e);
                    throw e;
                } finally {
                    if (!isAutopilot) setLoading(false);
                }
            };



            const writeProse = async (actIdx, sceneIdx, beatIdx, currentStory = story, isAutopilot = false) => {
                const storyToUse = currentStory || story;
                setLoading(true);
                const sId = `${actIdx}-${sceneIdx}`;
                const bId = `${sId}-${beatIdx}`;
                const beat = storyToUse.beats[sId]?.[beatIdx];
                if (!beat) throw new Error(`Beat not found at index ${beatIdx} for ${sId}`);
                const scene = storyToUse.scenes[actIdx][sceneIdx];

                // 0. AGENTIC PRE-STEP: Ensure Character Profiles
                let castWasUpdated = false;
                const mutableCast = [...storyToUse.cast];

                const sceneCharacters = scene.cast_names || [];

                for (const name of sceneCharacters) {
                    const charOriginal = storyToUse.cast.find(c => c.name === name);
                    if (charOriginal && !charOriginal.details?.deep_profile) {
                        await getCharacterDetails(name, mutableCast);
                        castWasUpdated = true;
                    }
                }

                // If profiles updated, we use the new cast list effectively
                // In a perfect immutable world we'd update storyToUse here, but let's just use mutableCast for the prompt context
                if (castWasUpdated) {
                    setStory(prev => ({ ...prev, cast: mutableCast }));
                    // We should ideally update storyToUse too if we were strict, but the prompt construction uses mutableCast anyway
                }

                const prevBeatIdx = beatIdx - 1;
                const nextBeatIdx = beatIdx + 1;

                const prevBeat = prevBeatIdx >= 0 ? storyToUse.beats[sId][prevBeatIdx] : null;
                const nextBeat = nextBeatIdx < storyToUse.beats[sId].length ? storyToUse.beats[sId][nextBeatIdx] : null;

                const prevText = prevBeatIdx >= 0 && storyToUse.prose[`${sId}-${prevBeatIdx}`]?.final
                    ? storyToUse.prose[`${sId}-${prevBeatIdx}`].final
                    : "[Scene Start]";

                // Full text context
                let fullSceneText = "";
                for (let i = 0; i < beatIdx; i++) {
                    if (storyToUse.prose[`${sId}-${i}`]?.final) {
                        fullSceneText += storyToUse.prose[`${sId}-${i}`].final + "\n\n";
                    }
                }
                if (!fullSceneText) fullSceneText = "[Start of Scene]";

                // Scene Beats Outline
                const currentSceneBeats = storyToUse.beats[sId] || [];
                const sceneBeatsOutline = currentSceneBeats.map(b => `Beat ${b.number}: ${b.description}`).join('\n');

                const currentActScenes = storyToUse.scenes[actIdx] || [];
                const actScenesList = currentActScenes.map(s => `Scene ${s.number}: ${s.title} - ${s.description}`).join('\n');

                const activeCast = mutableCast.filter(c => scene.cast_names?.includes(c.name));
                const castContext = activeCast.map(c =>
                    `### ${c.name}\n- **Role:** ${c.role}\n- **Goal:** ${c.details?.goals}\n- **Deep Profile (Interview):**\n${c.details?.deep_profile || "No profile available."}`
                ).join('\n\n');

                // RAG: Retrieval for Beat Context
                setLoadingStep("Retrieving Context (RAG)...");
                const currentActNum = storyToUse.acts[actIdx].number;
                const currentSceneNum = scene.number;

                // Build query focused on the Beat + Scene + Characters
                const beatQuery = `Beat Action: ${beat.description}. Scene Context: ${scene.description}. Characters: ${scene.cast_names?.join(', ') || "None"}. Mood: ${beat.emotional_shift}`;

                // High threshold to ensure only truly relevant lore is injected into the prose
                // Query + Act Filter (Spoiler Protection checks Act number)
                const ragLoreDocs = await retrieveContext(beatQuery, 0.65, (meta) => {
                    return !meta.valid_from_act || meta.valid_from_act <= currentActNum;
                });

                // Format for Drafter
                const loreContext = ragLoreDocs.length > 0
                    ? ragLoreDocs.map(d => `### ${d.metadata.topic} (${d.metadata.relation || "Direct Match"})\n${d.text}`).join('\n\n')
                    : "No specific relevant world lore found for this moment.";

                const getPacingDescription = (val) => {
                    // (Keep reused helper logic if possible, but for replacement safety I'll include it)
                    if (Number(val) === 0) return "Pacing Mode: Slow / Atmospheric / Introspective...";
                    if (Number(val) === 2) return "Pacing Mode: Fast / High-Tension / Kinetic...";
                    return "Pacing Mode: Moderate / Dialogue-Heavy / Balanced...";
                };

                // Simplified pacing desc for replacement block to save tokens if logic is complex, 
                // but actually I should keep original text or I break it. 
                // I will just assume the generic pacing helper is fine or I need to copy it fully?
                // The Helper `getPacingDescription` is defined inside `writeProse`. I must copy it or move it out.
                // I will copy the simple version for now or move it out? 
                // Moving it out would be cleaner but risky with replace_file_content if I don't see it all.
                // I'll re-include the function body.

                const getPacingDescriptionIn = (val) => {
                    // ... (Full text from original)
                    if (Number(val) === 0) {
                        return `Pacing Mode: Slow / Atmospheric / Introspective
Pacing Instructions:
1.  **Expand Time:** Treat every second as if it lasts a minute. Slow the narrative clock down. Do not rush to the beat's conclusion.
2.  **Sensory Saturation:** You must engage at least three senses (sight, sound, smell/touch). Describe the texture of materials, the quality of the light, the ambient background noise.
3.  **Micro-Focus:** Instead of saying "He walked across the room," describe the sound of his boots on the floorboards and the dust motes swirling in his wake.
4.  **Internal Landscape:** Dive deep into the protagonist's psyche. Connect the external world to their internal memory or emotion.
5.  **Sentence Structure:** Use longer, flowing, compound-complex sentences. Allow for poetic rhythm.
6.  **Worldbuilding:** If a prop or location is mentioned, describe its history, wear-and-tear, or cultural significance.

FORBIDDEN:
- Summary narration (e.g., "They ate dinner and went to bed.")
- Skipping over transitions.
- "White Room" syndrome (dialogue without setting).`;
                    }
                    if (Number(val) === 2) {
                        return `Pacing Mode: Fast / High-Tension / Kinetic
Pacing Instructions:
1.  **Immediate Stimulus-Response:** Write chronologically and viscerally. [Event happens] -> [Character reacts immediately]. There is no time for processing.
2.  **Cut the Fluff:** Remove internal monologue. The character is not thinking about their childhood; they are thinking about survival.
3.  **Verbs over Adjectives:** Use strong, active verbs (smashed, bolted, tore, scrambled). Minimize adjectives and adverbs.
4.  **Sentence Structure:** Use short, staccato sentences. Fragments are acceptable for impact. (e.g., "Silence. Then a scream.")
5.  **Physicality:** Focus on pain, adrenaline, heart rate, and breath. The focus is entirely on the body and the immediate physical threat.

FORBIDDEN:
- Flashbacks or memories.
- Lengthy descriptions of scenery.
- Complex metaphors.
- Passive voice.`;
                    }
                    return `Pacing Mode: Moderate / Dialogue-Heavy / Balanced
Pacing Instructions:
1.  **The Tennis Match:** Focus on the back-and-forth flow of interaction. If there is dialogue, ensure it snaps back and forth.
2.  **Stage Business:** Characters should never just talk. Give them "business" to do—fiddling with a pen, pouring a drink, pacing, checking a device. Use these actions to punctuate the dialogue.
3.  **Subtext:** Focus on what is *not* being said. Use facial expressions and small gestures to hint at true feelings.
4.  **Sentence Structure:** Use a balanced mix of short and long sentences. Paragraphs should be of average length.
5.  **Efficiency:** Describe the setting only enough to ground the reader, then focus on the characters' goals.

FORBIDDEN:
- Long monologues without interruption.
- Excessive introspection that halts the conversation.
- Purely functional dialogue (ensure characters have distinct voices).`;
                };

                const pacingDesc = getPacingDescriptionIn(beat.pacing !== undefined ? beat.pacing : 1);
                const valenceDesc = getValenceDescription(beat.valence);

                try {
                    setLoadingStep("Agent 2/4: Drafting...");
                    const drafterSystemPrompt = PROMPTS.drafter
                        .replace("{scene_description}", scene.description)
                        .replace("{subtext}", beat.emotional_shift || "None")
                        .replace("{pacing}", pacingDesc)
                        .replace("{voices}", castContext)
                        .replace("{lore}", loreContext)
                        .replace("{valence}", valenceDesc)
                        .replace("{style_guide}", storyToUse.style?.writing_guide ? `Writing Guide: ${storyToUse.style.writing_guide}\nGenre: ${storyToUse.style.genre}\nMood: ${storyToUse.style.mood}` : "Standard Narrative");

                    const drafterUserPrompt = `
# STORY TIMELINE

## Previous Beat (Context)
### Description
${prevBeat ? prevBeat.description : "Start of Scene"}

## FULL SCENE HISTORY
${fullSceneText}

## Current Beat (TASK)
### Description
${beat.description}
### Objective
Write the prose for this beat.

## Next Beat (Future)
### Description
${nextBeat ? nextBeat.description : "End of Scene"}

# CRITICAL INSTRUCTION
Write ONLY the content for the CURRENT BEAT. 
- Do not repeat the Previous Beat.
- Do not encroach on the Next Beat.
- Bridge them explicitly.
`;
                    const draft = await callAI(drafterUserPrompt, drafterSystemPrompt, false, "Drafter");

                    setLoadingStep("Agent 3/4: Polishing...");
                    const editorSystemPrompt = PROMPTS.editor
                        .replace("{draft}", draft)
                        .replace("{scene_description}", scene.description)
                        .replace("{subtext}", beat.emotional_shift || "None")
                        .replace("{pacing}", pacingDesc)
                        .replace("{voices}", castContext)
                        .replace("{lore}", loreContext)
                        .replace("{valence}", valenceDesc)
                        .replace("{style_guide}", storyToUse.style?.writing_guide ? `Writing Guide: ${storyToUse.style.writing_guide}\nGenre: ${storyToUse.style.genre}\nMood: ${storyToUse.style.mood}` : "Standard Narrative")
                        .replace("{scene_beats}", sceneBeatsOutline)
                        .replace("{scene_list}", actScenesList)
                        .replace("{prev_beat_text}", prevText);
                    const final = await callAI("Polish this draft according to the rules.", editorSystemPrompt, false, "Editor");

                    let nextStory = { ...storyToUse, prose: { ...storyToUse.prose, [bId]: { draft, final } } };
                    if (castWasUpdated) nextStory.cast = mutableCast;

                    // --- RIPPLE VALIDATION START ---
                    if (nextBeat) {
                        setLoadingStep("Agent 4/4: Script Doctor: Checking Continuity...");
                        const validatorPrompt = PROMPTS.beatValidator
                            .replace("{next_beat_desc}", nextBeat.description)
                            .replace("{scene_goal}", scene.description)
                            .replace("{prose_summary}", final);

                        try {
                            const validation = await callAI("Validate continuity.", validatorPrompt, true, "Script Doctor");
                            if (validation.valid === false && validation.rectified_beats) {
                                console.log("Ripple Effect: Beats rewritten due to prose deviation.", validation.reason);
                                if (!isAutopilot) alert(`Ripple Effect: The story has changed course!\nReason: ${validation.reason}\nFuture beats have been rewritten.`);

                                const currentBeats = nextStory.beats[sId];
                                const keptBeats = currentBeats.slice(0, beatIdx + 1);
                                const newFutureBeats = validation.rectified_beats.map((b, i) => ({
                                    ...b,
                                    number: beatIdx + 2 + i // renumber sequentially
                                }));

                                nextStory.beats[sId] = [...keptBeats, ...newFutureBeats];
                            }
                        } catch (err) {
                            console.warn("Validator failed, proceeding anyway:", err);
                        }
                    }
                    if (!nextBeat) {
                        setLoadingStep("Final Agent: Archiving...");
                        const currentLoreList = nextStory.lore.map(l => l.topic).join(', ');
                        const archivistSystemPrompt = PROMPTS.archivist
                            .replace("{text}", fullSceneText + "\n\n" + final)
                            .replace("{cast_summary}", activeCast.map(c => c.name).join(', '))
                            .replace("{current_lore}", currentLoreList);

                        const updates = await callAI("Analyze the full scene for updates.", archivistSystemPrompt, true, "Archivist");
                        // We need to apply logic of handleWorldUpdates to nextStory manually for return
                        if (updates) {
                            // ... (Logic to update cast/lore in nextStory) ... 
                            // Simplifying for brevity/safety:
                            // We can rely on the fact that handleWorldUpdates runs ON THE STATE 
                            // but we need it in nextStory for the CHAIN if we were going to use it immediately.
                            // In this autopilot flow, the prose is the main output. 
                            // The next beat loop uses `storyToUse.prose`.
                        }
                        handleWorldUpdates(updates, currentActNum, currentSceneNum);
                    }

                    setStory(nextStory); // Sync UI
                    showToast("Prose written and saved!");
                    return nextStory;
                } catch (e) { alert(e.message); throw e; } finally { if (!isAutopilot) setLoading(false); }
            };

            const copyFullScene = () => {
                if (selectedAct === null || selectedScene === null) return;
                const scene = story.scenes[selectedAct][selectedScene];
                const sId = `${selectedAct}-${selectedScene}`;
                const beats = story.beats[sId] || [];
                let text = `SCENE ${scene.number}: ${scene.title.toUpperCase()}\n\n`;
                beats.forEach((beat, idx) => {
                    const bId = `${sId}-${idx}`;
                    if (story.prose[bId]?.final) text += story.prose[bId].final + "\n\n";
                });
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.select();
                try { document.execCommand('copy'); showToast("Copied to clipboard!"); } catch (err) { alert("Copy failed."); }
                document.body.removeChild(textArea);
            };

            const handleAutopilot = async () => {
                const conceptToUse = inputConcept;
                if (!conceptToUse) return;

                if (!window.confirm("AUTOPILOT MODE: This will generate a full story from your concept. Existing data may be overwritten. Continue?")) return;

                try {
                    // 1. Architect Story
                    const storyBible = await initStory(true);
                    setView('dashboard'); // Present progress

                    // 2. Weave Scenes for Act 1
                    // Note: Act index is 0
                    const scenesStory = await generateScenes(0, storyBible, true);
                    setView('structure'); // Present progress

                    // 3. Direct Beats for Act 1, Scene 1 (index 0)
                    // We only do the first scene automatically to start
                    const beatsStory = await generateBeats(0, 0, scenesStory, true);
                    setView('writer'); // Present progress

                    // 4. Write Prose for All Beats in Scene 1
                    const sId = "0-0";
                    let currentStory = beatsStory;
                    if (!currentStory.beats[sId] || currentStory.beats[sId].length === 0) throw new Error("No beats generated.");

                    let i = 0;
                    let beatsProcessed = 0;
                    while (i < currentStory.beats[sId].length) {
                        currentStory = await writeProse(0, 0, i, currentStory, true);

                        beatsProcessed++;
                        if (beatsProcessed % 3 === 0 && i < currentStory.beats[sId].length - 1) {
                            showToast("Cooling down AI (5s)...");
                            await new Promise(resolve => setTimeout(resolve, 5000));
                        }

                        i++;
                    }

                    showToast("Autopilot Complete: First Scene Written!");

                } catch (e) {
                    console.error(e);
                    alert("Autopilot Stopped: " + e.message);
                } finally {
                    setLoading(false);
                }
            };

            const handleAutoGenerateScene = async (actIdx, sceneIdx) => {
                if (!window.confirm("Auto-Write this entire scene? This will generate beats (if missing) and write prose for every beat.")) return;

                try {
                    let currentStory = story;

                    // Check if beats exist, if not generate them
                    const sId = `${actIdx}-${sceneIdx}`;
                    if (!currentStory.beats[sId]) {
                        currentStory = await generateBeats(actIdx, sceneIdx, currentStory, true);
                    }

                    if (!currentStory.beats[sId] || currentStory.beats[sId].length === 0) throw new Error("No beats found or generated.");

                    let i = 0;
                    let beatsProcessed = 0;
                    while (i < currentStory.beats[sId].length) {
                        currentStory = await writeProse(actIdx, sceneIdx, i, currentStory, true);

                        beatsProcessed++;
                        if (beatsProcessed % 3 === 0 && i < currentStory.beats[sId].length - 1) {
                            showToast("Cooling down AI (5s)...");
                            await new Promise(resolve => setTimeout(resolve, 5000));
                        }

                        i++;
                    }
                    showToast("Scene Auto-Written!");
                } catch (e) {
                    console.error(e);
                    alert("Auto-Write Error: " + e.message);
                } finally {
                    setLoading(false);
                }
            };

            const saveModel = () => {
                if (openRouterModel && !savedModels.includes(openRouterModel)) {
                    setSavedModels([...savedModels, openRouterModel]);
                }
            };

            // ... (rest of functions) ...

            // Wait, I need to insert this BEFORE return, but replace_file_content needs to match context.
            // I'll target the saveModel function block to insert before it. 
            // Actually, I can insert it right before `const saveModel` in the existing code.


            const deleteModel = (modelToDelete) => {
                setSavedModels(savedModels.filter(m => m !== modelToDelete));
            };

            const fetchGeminiModels = async () => {
                if (!apiKey) return;
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                    if (!response.ok) throw new Error("Failed to fetch models");
                    const data = await response.json();
                    const models = data.models
                        .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                        .map(m => m.name.replace("models/", ""));
                    setGeminiModelsList(models);
                    // If current model is not in list (and list is not empty), default to first available
                    if (models.length > 0 && !models.includes(geminiModel)) {
                        /* Optional logic: could setGeminiModel(models[0]); but safer to leave it if it might be valid but unlisted */
                    }
                } catch (e) {
                    console.error("Error fetching Gemini models:", e);
                    alert("Failed to fetch Gemini models. Check your API Key.");
                }
            };

            // Fetch models when entering settings or when API key changes
            useEffect(() => {
                if (view === 'settings' && apiProvider === 'gemini' && apiKey) {
                    fetchGeminiModels();
                }
            }, [view, apiProvider, apiKey]);

            return (
                <div className="flex h-screen bg-slate-950 text-slate-200 overflow-hidden">
                    <div className={`fixed inset-y-0 left-0 z-50 w-72 bg-slate-900 border-r border-slate-800 flex flex-col transform transition-transform duration-300 md:translate-x-0 ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        <div className="p-4 flex justify-between border-b border-slate-800">
                            <h2 className="font-bold flex gap-2"><Book className="text-indigo-400" /> EllipsisProse 0.41</h2>
                            <button onClick={() => setIsSidebarOpen(false)} className="md:hidden"><X /></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-1">
                            <button onClick={() => setView('setup')} className={`nav-btn ${view === 'setup' ? 'active' : ''}`}><Sparkles size={16} /> New Story</button>
                            <button onClick={() => setView('dashboard')} className={`nav-btn ${view === 'dashboard' ? 'active' : ''}`}><Activity size={16} /> Overview</button>
                            <button onClick={() => setView('settings')} className={`nav-btn ${view === 'settings' ? 'active' : ''}`}><Settings size={16} /> Settings</button>
                            <button onClick={() => setView('logs')} className={`nav-btn ${view === 'logs' ? 'active' : ''}`}><History size={16} /> Prompt Log</button>
                            <button onClick={() => setView('cast')} className={`nav-btn ${view === 'cast' ? 'active' : ''}`}><Users size={16} /> Cast & Roster</button>
                            <button onClick={() => setView('lore')} className={`nav-btn ${view === 'lore' ? 'active' : ''}`}><Globe size={16} /> World Lore</button>
                            <button onClick={() => setView('inspector')} className={`nav-btn ${view === 'inspector' ? 'active' : ''}`}><Search size={16} /> RAG Inspector</button>
                            <button onClick={() => setView('structure')} className={`nav-btn ${view === 'structure' ? 'active' : ''}`}><Layers size={16} /> Act Planner</button>
                            {story.acts.map((act, idx) => (
                                <div key={idx} className="ml-2 mt-2">
                                    <button
                                        onClick={() => toggleAct(idx)}
                                        className="w-full flex items-center justify-between text-[10px] text-slate-500 font-bold uppercase px-3 mb-1 hover:text-slate-300"
                                    >
                                        Act {act.number}
                                        <div className="text-slate-600">
                                            {collapsedActs[idx] ? <ChevronRight size={12} /> : <ChevronDown size={12} />}
                                        </div>
                                    </button>
                                    {!collapsedActs[idx] && story.scenes[idx]?.map((scene, sIdx) => {
                                        const colorClass = getSceneColor(idx, sIdx);
                                        return (
                                            <button key={sIdx} onClick={() => { setSelectedAct(idx); setSelectedScene(sIdx); setView('writer'); setIsSidebarOpen(false); }} className={`nav-btn text-xs pl-6 truncate ${view === 'writer' && selectedScene === sIdx ? 'text-indigo-300' : colorClass}`}>{scene.number}. {scene.title}</button>
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                        <div className="p-4 border-t border-slate-800 flex gap-2">
                            <button onClick={handleExport} className="flex-1 bg-slate-800 hover:bg-slate-700 py-2 rounded text-xs flex justify-center gap-2 transition-colors"><Download size={14} /> Save JSON</button>
                            <button onClick={handleExportEpub} className="flex-1 bg-indigo-900 hover:bg-indigo-800 py-2 rounded text-xs flex justify-center gap-2 transition-colors text-indigo-100"><Book size={14} /> Export EPUB</button>
                            <button onClick={() => fileInputRef.current.click()} className="flex-1 bg-slate-800 hover:bg-slate-700 py-2 rounded text-xs flex justify-center gap-2 transition-colors"><Upload size={14} /> Load</button>
                            <input type="file" ref={fileInputRef} onChange={handleImport} className="hidden" accept=".json" />
                        </div>
                    </div>

                    <div className="flex-1 flex flex-col h-full relative w-full md:ml-72">
                        <header className="h-16 border-b border-slate-800 bg-slate-900/50 flex justify-between px-6 items-center backdrop-blur-sm z-20">
                            <div className="flex items-center gap-4">
                                <button onClick={() => setIsSidebarOpen(true)} className="md:hidden"><Menu /></button>
                                <h2 className="font-bold text-lg capitalize">{view}</h2>
                                {loading && <span className="text-xs text-indigo-400 flex items-center gap-2"><RefreshCw size={14} className="animate-spin" /> {loadingStep}</span>}
                            </div>
                        </header>

                        <main className="flex-1 overflow-y-auto p-4 md:p-8">
                            {view === 'setup' && (
                                <div className="max-w-xl mx-auto py-20 text-center animate-fade-in">
                                    <div className="bg-indigo-600 w-16 h-16 rounded-2xl flex items-center justify-center mx-auto mb-6"><Sparkles size={32} color="white" /></div>
                                    <h1 className="text-2xl font-bold mb-4">EllipsisProse 0.41</h1>
                                    <p className="text-slate-400 mb-6">Enter a title and concept. The AI Architect will build your story bible.</p>
                                    <input className="w-full bg-slate-900 border border-slate-800 rounded-xl p-4 mb-4 focus:ring-2 focus:ring-indigo-500 outline-none font-bold" placeholder="Story Title (e.g. The Last Starship)" value={inputTitle} onChange={e => setInputTitle(e.target.value)} />
                                    <textarea className="w-full bg-slate-900 border border-slate-800 rounded-xl p-4 h-32 mb-4 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Concept (e.g. A fantasy world where magic costs memories...)" value={inputConcept} onChange={e => setInputConcept(e.target.value)} />

                                    {/* Import Lore UI */}
                                    <div className="mb-6">
                                        <div className="flex justify-between items-center mb-2">
                                            <label className="text-xs font-bold text-slate-500 uppercase">Existing Lore / Notes (Optional)</label>
                                            <button onClick={() => loreInputRef.current.click()} className="text-xs text-indigo-400 hover:text-indigo-300 flex items-center gap-1">
                                                <Upload size={12} /> Upload Text/MD
                                            </button>
                                            <input type="file" ref={loreInputRef} onChange={handleLoreImport} className="hidden" accept=".txt,.md" />
                                        </div>
                                        {importedLoreText && (
                                            <div className="relative animate-fade-in">
                                                <textarea
                                                    className="w-full bg-slate-950 border border-slate-800 rounded-lg p-3 h-24 text-xs font-mono text-slate-400 focus:border-indigo-500 outline-none resize-y"
                                                    value={importedLoreText}
                                                    onChange={(e) => setImportedLoreText(e.target.value)}
                                                    placeholder="Uploaded lore content will appear here..."
                                                />
                                                <button
                                                    onClick={() => setImportedLoreText("")}
                                                    className="absolute top-2 right-2 text-slate-600 hover:text-red-400"
                                                    title="Clear Lore"
                                                >
                                                    <X size={12} />
                                                </button>
                                            </div>
                                        )}
                                    </div>

                                    <div className="flex gap-4">
                                        <button onClick={() => initStory(false)} disabled={loading || !inputConcept} className="flex-1 bg-indigo-600 hover:bg-indigo-500 py-4 rounded-xl font-bold transition-all disabled:opacity-50">Initialize Story</button>
                                        <button onClick={handleAutopilot} disabled={loading || !inputConcept} className="flex-1 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 py-4 rounded-xl font-bold transition-all disabled:opacity-50 flex items-center justify-center gap-2"><Zap size={20} /> Autopilot</button>
                                    </div>
                                </div>
                            )}

                            {view === 'dashboard' && (
                                <div className="max-w-5xl mx-auto space-y-8 animate-fade-in">
                                    <div className="grid md:grid-cols-2 gap-6">
                                        <div className="p-6 bg-slate-900 rounded-xl border border-slate-800 space-y-6">
                                            <div>
                                                <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Title</h3>
                                                <input
                                                    className="w-full bg-transparent border-b border-transparent hover:border-slate-700 focus:border-indigo-500 outline-none font-bold text-lg text-white transition-colors"
                                                    value={story.title || ""}
                                                    onChange={(e) => setStory({ ...story, title: e.target.value })}
                                                    placeholder="Untitled Story"
                                                />
                                            </div>
                                            <div>
                                                <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Concept</h3>
                                                <p className="font-light">{story.concept}</p>
                                            </div>
                                            <div>
                                                <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Status Quo</h3>
                                                <p className="text-sm text-slate-400">{story.status_quo}</p>
                                            </div>
                                            <div>
                                                <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Inciting Incident</h3>
                                                <p className="text-sm text-slate-400">{story.inciting_incident}</p>
                                            </div>
                                            <div>
                                                <h3 className="text-xs font-bold text-indigo-400 uppercase mb-2">Themes</h3>
                                                <p className="text-sm text-slate-400">{story.themes}</p>
                                            </div>
                                        </div>
                                        <div className="space-y-6">
                                            <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                                <h3 className="text-xs font-bold text-pink-400 uppercase mb-4 flex gap-2"><Feather size={16} /> Style & Tone</h3>
                                                <div className="space-y-2">
                                                    <div className="flex gap-2"><span className="text-xs font-bold text-slate-500 uppercase w-16">Genre</span><span className="text-sm">{story.style?.genre}</span></div>
                                                    <div className="flex gap-2"><span className="text-xs font-bold text-slate-500 uppercase w-16">Mood</span><span className="text-sm">{story.style?.mood}</span></div>
                                                    <div className="mt-2 text-sm text-slate-400 italic border-l-2 border-slate-700 pl-3">{story.style?.writing_guide}</div>
                                                </div>
                                            </div>
                                            <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                                <h3 className="text-xs font-bold text-emerald-400 uppercase mb-4 flex gap-2"><GitBranch size={16} /> Threads</h3>
                                                <div className="space-y-4">{story.threads.map(t => <div key={t.id} className="p-3 bg-slate-950 rounded border border-slate-800/50"><div className="font-bold mb-1">{t.name}</div><div className="text-sm text-slate-400">{t.description}</div></div>)}</div>
                                            </div>
                                            <div className="p-6 bg-slate-900 rounded-xl border border-slate-800">
                                                <h3 className="text-xs font-bold text-blue-400 uppercase mb-4 flex gap-2"><Globe size={16} /> Lore</h3>
                                                <div className="space-y-4">{story.lore.map((l, i) => <div key={i} className="text-sm border-b border-slate-800/50 pb-4 flex flex-col gap-1"><span className="text-blue-300 font-mono font-bold">{l.topic}</span><span className="text-slate-400">{l.detail}</span></div>)}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {view === 'cast' && (
                                <div className="grid md:grid-cols-2 gap-6 max-w-6xl mx-auto animate-fade-in">
                                    {story.cast && story.cast.map((c, i) => <CharacterCard key={i} c={c} />)}
                                </div>
                            )}

                            {view === 'lore' && (
                                <div className="max-w-4xl mx-auto space-y-6 animate-fade-in">
                                    <div className="flex justify-between items-center mb-6">
                                        <h2 className="text-2xl font-bold flex items-center gap-2">
                                            <Globe className="text-blue-400" /> World Lore
                                            {ragStatus === 'indexing' && <span className="text-xs bg-indigo-900 text-indigo-200 px-2 py-1 rounded animate-pulse">Indexing...</span>}
                                        </h2>
                                        <button
                                            onClick={() => ingestLoreBatch(story.lore)}
                                            disabled={ragStatus === 'indexing' || !apiKey && !openRouterKey}
                                            className="text-xs bg-slate-800 hover:bg-slate-700 px-3 py-2 rounded flex items-center gap-2"
                                        >
                                            <RefreshCw size={12} className={ragStatus === 'indexing' ? 'animate-spin' : ''} /> Re-Index Graph
                                        </button>
                                    </div>
                                    <div className="grid gap-4">
                                        {story.lore.map((l, i) => (
                                            <div key={i} className="bg-slate-900 rounded-xl border border-slate-800 p-4 md:p-6 transition-all hover:border-slate-700">
                                                <div className="flex flex-col md:flex-row justify-between items-start gap-3 mb-2">
                                                    <h3 className="font-bold text-lg text-blue-300">{l.topic}</h3>
                                                    <div className="flex items-start gap-2 self-start md:self-auto">
                                                        <div className="flex flex-col gap-1 text-xs bg-slate-950 p-2 rounded border border-slate-800 min-w-[200px]">
                                                            <div className="flex items-center justify-between gap-2 border-b border-slate-800/50 pb-1 mb-1">
                                                                <span className="text-slate-500 font-bold uppercase">Act</span>
                                                                <select
                                                                    className="bg-transparent text-slate-300 outline-none text-right w-full cursor-pointer"
                                                                    value={l.valid_from_act || 1}
                                                                    onChange={(e) => {
                                                                        const val = parseInt(e.target.value);
                                                                        const newLore = [...story.lore];
                                                                        newLore[i].valid_from_act = val;
                                                                        newLore[i].valid_from_scene = 1;
                                                                        setStory(prev => ({ ...prev, lore: newLore }));
                                                                    }}
                                                                >
                                                                    {story.acts.map(a => <option key={a.number} value={a.number}>Act {a.number}: {a.title.substring(0, 30)}...</option>)}
                                                                </select>
                                                            </div>
                                                            <div className="flex items-center justify-between gap-2">
                                                                <span className="text-slate-500 font-bold uppercase">Scene</span>
                                                                <select
                                                                    className="bg-transparent text-slate-300 outline-none text-right w-full cursor-pointer"
                                                                    value={l.valid_from_scene || 1}
                                                                    onChange={(e) => {
                                                                        const val = parseInt(e.target.value);
                                                                        const newLore = [...story.lore];
                                                                        newLore[i].valid_from_scene = val;
                                                                        setStory(prev => ({ ...prev, lore: newLore }));
                                                                    }}
                                                                >
                                                                    {(() => {
                                                                        const actIdx = (l.valid_from_act || 1) - 1;
                                                                        const scenes = story.scenes[actIdx] || [];
                                                                        if (scenes.length === 0) return <option value="1">Scene 1</option>;
                                                                        return scenes.map(s => <option key={s.number} value={s.number}>Sc {s.number}: {s.title.substring(0, 30)}...</option>);
                                                                    })()}
                                                                </select>
                                                            </div>
                                                        </div>
                                                        <button
                                                            onClick={() => handleDeleteLore(i)}
                                                            className="p-1.5 text-slate-500 hover:text-red-400 hover:bg-slate-800 rounded transition-colors mt-1"
                                                            title="Delete Lore Item"
                                                        >
                                                            <Trash2 size={14} />
                                                        </button>
                                                    </div>
                                                </div>
                                                <p className="text-slate-400 leading-relaxed">{l.detail}</p>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {view === 'structure' && (
                                <div className="max-w-4xl mx-auto space-y-6 animate-fade-in">
                                    {story.acts.map((act, idx) => (
                                        <div key={idx} className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden">
                                            <div className="p-6 border-b border-slate-800 flex justify-between items-center bg-slate-800/20">
                                                <div><span className="text-xs font-bold text-slate-500 uppercase">Act {act.number}</span><h3 className="text-xl font-bold">{act.title}</h3><p className="text-sm text-slate-400">{act.description}</p></div>
                                                <button onClick={() => requestSceneWeaving(idx)} disabled={loading} className="bg-indigo-600 px-4 py-2 rounded font-bold text-sm hover:bg-indigo-500">{story.scenes[idx] ? 'Re-Weave Scenes' : 'Weave Scenes'}</button>
                                            </div>
                                            {story.scenes[idx] && <div className="p-4 bg-slate-950/50 border-b border-slate-800 space-y-4">
                                                <ThreadVisualizer scenes={story.scenes[idx]} threads={story.threads} />
                                                <ValenceGraph dataPoints={story.scenes[idx].map(s => s.valence)} />
                                            </div>}
                                            {story.scenes[idx] && <div className="divide-y divide-slate-800">{story.scenes[idx].map((s, si) => (
                                                <div key={si} className="p-4 flex justify-between items-center hover:bg-slate-800/30 group">
                                                    <div className="flex gap-4"><div className="w-8 h-8 rounded-full bg-slate-800 flex items-center justify-center text-xs font-bold text-slate-500">{s.number}</div><div><h4 className="font-bold">{s.title}</h4><p className="text-sm text-slate-500">{s.description}</p></div></div>
                                                    <div className="flex items-center gap-3"><ValenceBadge score={s.valence} /><button onClick={() => { setSelectedAct(idx); setSelectedScene(si); setView('writer'); }} className="text-indigo-400 opacity-0 group-hover:opacity-100 transition-opacity"><Edit3 size={18} /></button></div>
                                                </div>
                                            ))}</div>}
                                        </div>
                                    ))}
                                </div>
                            )}

                            {view === 'writer' && selectedAct !== null && selectedScene !== null && (
                                <div className="max-w-6xl mx-auto space-y-8 animate-fade-in pb-32">
                                    <div className="bg-slate-900 p-6 rounded-xl border border-slate-800 flex justify-between items-start">
                                        <div>
                                            <button onClick={() => setView('structure')} className="text-xs text-slate-500 flex items-center gap-1 mb-2 hover:text-white"><ArrowLeft size={12} /> Back</button>
                                            <div className="flex items-center gap-3 mb-2"><h2 className="text-2xl font-bold">{story.scenes[selectedAct][selectedScene].title}</h2><ValenceBadge score={story.scenes[selectedAct][selectedScene].valence} /></div>
                                            <p className="text-slate-400">{story.scenes[selectedAct][selectedScene].description}</p>
                                        </div>
                                        <div className="flex flex-col gap-2">
                                            <button onClick={copyFullScene} className="bg-slate-800 p-2 rounded hover:bg-slate-700 transition-colors"><Copy size={18} /></button>
                                            <button onClick={() => requestBeatGeneration(selectedAct, selectedScene)} disabled={loading} className="bg-emerald-600 px-4 py-2 rounded font-bold shadow-lg flex items-center gap-2"><Sparkles size={16} /> {story.beats[`${selectedAct}-${selectedScene}`] ? 'Re-Do Beats' : 'Beats'}</button>
                                            <button onClick={() => handleAutoGenerateScene(selectedAct, selectedScene)} disabled={loading} className="bg-purple-600 px-4 py-2 rounded font-bold shadow-lg flex items-center gap-2" title="Auto-write prose for all beats"><Zap size={16} /> Auto-Write</button>
                                        </div>
                                    </div>
                                    <div className="space-y-12">
                                        {story.beats[`${selectedAct}-${selectedScene}`]?.map((beat, bi) => {
                                            const bId = `${selectedAct}-${selectedScene}-${bi}`;
                                            const prose = story.prose[bId];
                                            const isCollapsed = collapsedProse[bId] || false;

                                            return (
                                                <div key={bi} className="flex flex-col xl:flex-row gap-8">
                                                    <div className="xl:w-80 shrink-0">
                                                        <div className={`p-5 rounded-xl border transition-all ${prose ? 'bg-slate-900/40 border-slate-800' : 'bg-slate-900 border-indigo-500/30'}`}>
                                                            <div className="flex justify-between mb-2"><span className="text-xs font-bold text-indigo-400">BEAT {bi + 1}</span><ValenceBadge score={beat.valence} /></div>
                                                            <textarea
                                                                className="w-full bg-slate-950 text-sm font-medium mb-4 p-2 rounded border border-transparent hover:border-slate-700 focus:border-indigo-500 outline-none resize-none transition-colors field-sizing-content"
                                                                value={beat.description}
                                                                onChange={(e) => handleBeatChange(selectedAct, selectedScene, bi, e.target.value)}
                                                                rows={4}
                                                            />
                                                            <div className="text-[10px] text-slate-500 uppercase font-bold italic mb-4">{beat.emotional_shift}</div>
                                                            {!prose ? (
                                                                <div className="space-y-4 pt-4 border-t border-slate-800">
                                                                    <div className="flex justify-between text-[10px] text-slate-500 uppercase font-bold"><span>Slow</span><span>Balanced</span><span>Fast</span></div>
                                                                    <input type="range" min="0" max="2" step="1" value={beat.pacing !== undefined ? beat.pacing : 1} onChange={e => handleBeatPacingChange(selectedAct, selectedScene, bi, parseInt(e.target.value, 10))} />
                                                                    <button onClick={() => writeProse(selectedAct, selectedScene, bi)} disabled={loading} className="w-full bg-indigo-600 py-2 rounded font-bold text-sm hover:bg-indigo-500 flex justify-center gap-2"><Feather size={14} /> Write</button>
                                                                </div>
                                                            ) : (
                                                                <div className="flex gap-2 pt-4 border-t border-slate-800">
                                                                    <button onClick={() => handlePlayTTS(bId, prose.final)} className={`flex-1 py-2 rounded border transition-colors flex justify-center items-center ${audioState.id === bId && audioState.status !== 'idle' ? 'bg-indigo-900 border-indigo-500 text-indigo-200' : 'bg-slate-950 border-slate-800 text-emerald-400 hover:text-emerald-300'}`}>
                                                                        {audioState.id === bId && audioState.status === 'loading' ? <Loader2 size={16} className="animate-spin" /> :
                                                                            audioState.id === bId && audioState.status === 'playing' ? <Square size={16} fill="currentColor" /> :
                                                                                audioCache[bId] ? <Play size={16} fill="currentColor" /> :
                                                                                    <Volume2 size={16} />}
                                                                    </button>
                                                                    <button onClick={() => writeProse(selectedAct, selectedScene, bi)} className="flex-1 py-2 bg-slate-950 rounded text-indigo-400 border border-slate-800 hover:text-indigo-300 flex justify-center items-center"><RefreshCw size={16} /></button>
                                                                    <button onClick={() => toggleProse(bId)} className="flex-1 py-2 bg-slate-950 rounded text-slate-400 border border-slate-800 hover:text-slate-200 flex justify-center items-center">
                                                                        {isCollapsed ? <ChevronRight size={16} /> : <ChevronDown size={16} />}
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                    <div className="flex-1">
                                                        {prose ? (
                                                            !isCollapsed && (
                                                                <div className="relative group/text animate-fade-in">
                                                                    <div className="absolute -left-4 top-0 bottom-0 w-1 bg-gradient-to-b from-indigo-500/0 via-indigo-500/20 to-indigo-500/0"></div>
                                                                    <div className="prose prose-invert max-w-none font-serif text-lg leading-loose text-slate-200" dangerouslySetInnerHTML={{ __html: parseMarkdown(prose.final) }} />
                                                                </div>
                                                            )
                                                        ) : <div className="h-full border-l-2 border-slate-900/50 ml-6 pl-12 flex flex-col justify-center text-slate-800 italic text-xl select-none"><PenTool className="w-12 h-12 mb-4 opacity-10" /> Waiting...</div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}

                            {view === 'logs' && (
                                <div className="max-w-6xl mx-auto space-y-6 animate-fade-in">
                                    <h2 className="text-2xl font-bold mb-6 flex items-center gap-2"><History className="text-indigo-400" /> Prompt Log</h2>
                                    <div className="space-y-4">
                                        {promptLog.length === 0 ? (
                                            <div className="text-center text-slate-500 py-20 italic">No prompts sent yet. Start writing!</div>
                                        ) : (
                                            promptLog.map((entry) => (
                                                <div key={entry.id} className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden">
                                                    <div className="p-4 bg-slate-800/30 border-b border-slate-800 flex justify-between items-center">
                                                        <div className="flex items-center gap-3">
                                                            <span className="text-xs font-mono text-slate-500">{entry.timestamp}</span>
                                                            <span className="text-sm font-bold text-indigo-400 uppercase tracking-wider">{entry.function}</span>
                                                        </div>
                                                        <button
                                                            onClick={() => { navigator.clipboard.writeText(`System: ${entry.systemPrompt}\n\nUser: ${entry.prompt}`); alert("Copied full context!"); }}
                                                            className="text-xs flex items-center gap-1 text-slate-500 hover:text-indigo-400 transition-colors"
                                                        >
                                                            <Copy size={12} /> Copy All
                                                        </button>
                                                    </div>
                                                    <div className="p-4 space-y-4 text-sm font-mono leading-relaxed">
                                                        <div>
                                                            <div className="text-[10px] text-slate-500 font-bold uppercase mb-1">System Prompt</div>
                                                            <div className="text-slate-400 whitespace-pre-wrap max-h-32 overflow-y-auto bg-slate-950 p-2 rounded custom-scrollbar">{entry.systemPrompt}</div>
                                                        </div>
                                                        <div>
                                                            <div className="text-[10px] text-slate-500 font-bold uppercase mb-1">User Prompt</div>
                                                            <div className="text-slate-300 whitespace-pre-wrap bg-slate-950 p-2 rounded">{entry.prompt}</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                </div>
                            )}

                            {view === 'inspector' && (
                                <div className="max-w-4xl mx-auto space-y-6 animate-fade-in">
                                    <h2 className="text-2xl font-bold mb-6 flex items-center gap-2"><Search className="text-indigo-400" /> RAG Inspector</h2>

                                    {/* Test Input */}
                                    <div className="bg-slate-900 p-6 rounded-xl border border-slate-800">
                                        <label className="block text-sm font-bold text-slate-400 mb-2">Test Query</label>
                                        <div className="flex gap-2">
                                            <input
                                                className="flex-1 bg-slate-950 border border-slate-800 rounded px-4 py-2 focus:ring-2 focus:ring-indigo-500 outline-none"
                                                placeholder="e.g., 'What acts of magic are illegal?'"
                                                value={ragTestQuery}
                                                onChange={e => setRagTestQuery(e.target.value)}
                                                onKeyDown={e => e.key === 'Enter' && handleRagTest()}
                                            />
                                            <button onClick={handleRagTest} disabled={ragTestLoading} className="bg-indigo-600 px-6 py-2 rounded font-bold hover:bg-indigo-500 disabled:opacity-50">
                                                {ragTestLoading ? <Loader2 className="animate-spin" /> : 'Search'}
                                            </button>
                                        </div>
                                    </div>

                                    {/* World Primer Status */}
                                    {worldPrimer && (
                                        <div className="bg-indigo-900/20 border border-indigo-500/30 p-4 rounded-xl">
                                            <h3 className="text-sm font-bold text-indigo-300 uppercase mb-2 flex items-center gap-2"><Book size={14} /> Active World Primer</h3>
                                            <div className="text-sm text-slate-300 max-h-32 overflow-y-auto whitespace-pre-wrap">{worldPrimer}</div>
                                        </div>
                                    )}

                                    {/* Results */}
                                    <div className="space-y-4">
                                        <h3 className="text-sm font-bold text-slate-500 uppercase">Retrieval Results</h3>
                                        {ragTestResults.length === 0 ? (
                                            <div className="text-center text-slate-600 italic py-10">Run a search to inspect vector matches.</div>
                                        ) : (
                                            ragTestResults.map((res, i) => (
                                                <div key={i} className="bg-slate-900 rounded-xl border border-slate-800 p-4">
                                                    <div className="flex justify-between items-start mb-2">
                                                        <div className="text-xs font-bold text-emerald-400 bg-emerald-900/30 px-2 py-0.5 rounded">
                                                            Score: {(res.score * 100).toFixed(1)}%
                                                        </div>
                                                        <div className="text-xs text-slate-500 font-mono">
                                                            Topic: {res.metadata.topic}
                                                        </div>
                                                    </div>
                                                    <p className="text-slate-300 text-sm leading-relaxed mb-2">{res.text}</p>

                                                    {/* Metadata Debug */}
                                                    <div className="text-[10px] text-slate-500 font-mono bg-slate-950 p-2 rounded">
                                                        {JSON.stringify(res.metadata)}
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                </div>
                            )}

                            {view === 'settings' && (
                                <div className="max-w-xl mx-auto py-10 animate-fade-in">
                                    <h2 className="text-2xl font-bold mb-6 flex items-center gap-2"><Settings className="text-indigo-400" /> Settings</h2>

                                    <div className="bg-slate-900 p-6 rounded-xl border border-slate-800 space-y-6">

                                        {/* API Provider Toggle */}
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Text Generation Provider</label>
                                            <div className="flex bg-slate-950 p-1 rounded-lg border border-slate-800">
                                                <button
                                                    onClick={() => setApiProvider('gemini')}
                                                    className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${apiProvider === 'gemini' ? 'bg-slate-800 text-white shadow' : 'text-slate-500 hover:text-slate-300'}`}
                                                >
                                                    Gemini (Google)
                                                </button>
                                                <button
                                                    onClick={() => setApiProvider('openrouter')}
                                                    className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${apiProvider === 'openrouter' ? 'bg-slate-800 text-white shadow' : 'text-slate-500 hover:text-slate-300'}`}
                                                >
                                                    OpenRouter
                                                </button>
                                            </div>
                                        </div>

                                        {/* Embedding Provider Toggle */}
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Embedding Provider (RAG)</label>
                                            <div className="flex bg-slate-950 p-1 rounded-lg border border-slate-800">
                                                <button
                                                    onClick={() => setEmbeddingProvider('gemini')}
                                                    className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${embeddingProvider === 'gemini' ? 'bg-slate-800 text-white shadow' : 'text-slate-500 hover:text-slate-300'}`}
                                                >
                                                    Gemini (Recommended)
                                                </button>
                                                <button
                                                    onClick={() => setEmbeddingProvider('openrouter')}
                                                    className={`flex-1 py-2 rounded-md text-sm font-bold transition-all ${embeddingProvider === 'openrouter' ? 'bg-slate-800 text-white shadow' : 'text-slate-500 hover:text-slate-300'}`}
                                                >
                                                    OpenRouter
                                                </button>
                                            </div>
                                        </div>

                                        {/* Gemini Settings */}
                                        {(apiProvider === 'gemini' || embeddingProvider === 'gemini') && (
                                            <div className="animate-fade-in">
                                                <label className="block text-sm font-bold text-slate-400 mb-2">Gemini API Key</label>
                                                <p className="text-xs text-slate-500 mb-2">Required for all AI features. Your key is stored locally.</p>
                                                <input
                                                    type="password"
                                                    value={apiKey}
                                                    onChange={(e) => setApiKey(e.target.value)}
                                                    className="w-full bg-slate-950 border border-slate-800 rounded px-3 py-2 text-sm focus:border-indigo-500 outline-none transition-colors mb-4"
                                                    placeholder="AIzaSy..."
                                                />

                                                {/* Only show Model Selector if Gemini is the Text Provider */}
                                                {apiProvider === 'gemini' && (
                                                    <div>
                                                        <label className="block text-sm font-bold text-slate-400 mb-2">Gemini Model</label>
                                                        <div className="flex gap-2">
                                                            <div className="relative flex-1">
                                                                <select
                                                                    value={geminiModel}
                                                                    onChange={(e) => setGeminiModel(e.target.value)}
                                                                    className="w-full bg-slate-950 border border-slate-800 rounded px-3 py-2 text-sm focus:border-indigo-500 outline-none appearance-none transition-colors"
                                                                >
                                                                    {geminiModelsList.length > 0 ? (
                                                                        geminiModelsList.map(m => <option key={m} value={m}>{m}</option>)
                                                                    ) : (
                                                                        <option value={geminiModel}>{geminiModel}</option>
                                                                    )}
                                                                </select>
                                                                <ChevronDown className="absolute right-3 top-2.5 text-slate-500 pointer-events-none" size={14} />
                                                            </div>
                                                            <button onClick={fetchGeminiModels} className="bg-slate-800 hover:bg-slate-700 text-slate-200 px-3 rounded border border-slate-700 transition-colors" title="Refresh Models">
                                                                <RefreshCw size={16} />
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}

                                                <p className="text-xs text-slate-500 mt-2">
                                                    Don't have a key? <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-indigo-400 hover:underline">Get one from Google AI Studio</a>.
                                                </p>
                                            </div>
                                        )}

                                        {/* OpenRouter Settings */}
                                        {(apiProvider === 'openrouter' || embeddingProvider === 'openrouter') && (
                                            <div className="space-y-4 animate-fade-in">
                                                <div>
                                                    <label className="block text-sm font-bold text-slate-400 mb-2">OpenRouter API Key</label>
                                                    <input
                                                        type="password"
                                                        value={openRouterKey}
                                                        onChange={(e) => setOpenRouterKey(e.target.value)}
                                                        className="w-full bg-slate-950 border border-slate-800 rounded px-3 py-2 text-sm focus:border-indigo-500 outline-none transition-colors"
                                                        placeholder="sk-or-..."
                                                    />
                                                </div>

                                                {/* Only show Model Selector if OpenRouter is the Text Provider */}
                                                {apiProvider === 'openrouter' && (
                                                    <div>
                                                        <label className="block text-sm font-bold text-slate-400 mb-2">Model ID</label>
                                                        <div className="flex gap-2">
                                                            <input
                                                                type="text"
                                                                value={openRouterModel}
                                                                onChange={(e) => setOpenRouterModel(e.target.value)}
                                                                className="flex-1 bg-slate-950 border border-slate-800 rounded px-3 py-2 text-sm focus:border-indigo-500 outline-none transition-colors"
                                                                placeholder="google/gemini-2.0-flash-001"
                                                            />
                                                            <button onClick={saveModel} className="bg-slate-800 hover:bg-slate-700 text-slate-200 px-3 rounded border border-slate-700 transition-colors" title="Save Model">
                                                                <Save size={16} />
                                                            </button>
                                                        </div>

                                                        {savedModels.length > 0 && (
                                                            <div className="mt-3 space-y-2">
                                                                <label className="text-xs font-bold text-slate-500 uppercase">Saved Models</label>
                                                                <div className="flex flex-wrap gap-2">
                                                                    {savedModels.map((model) => (
                                                                        <div key={model} className={`flex items-center gap-2 px-3 py-1 rounded-full border text-xs cursor-pointer hover:bg-slate-800 transition-colors ${openRouterModel === model ? 'bg-indigo-900/30 border-indigo-500/50 text-indigo-300' : 'bg-slate-950 border-slate-800 text-slate-400'}`} onClick={() => setOpenRouterModel(model)}>
                                                                            <span className="truncate max-w-[200px]">{model}</span>
                                                                            <button onClick={(e) => { e.stopPropagation(); deleteModel(model); }} className="hover:text-red-400 p-0.5 rounded-full hover:bg-slate-900/50">
                                                                                <X size={12} />
                                                                            </button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}

                                                <div className="mt-4 pt-4 border-t border-slate-800">
                                                    <p className="text-xs text-slate-500">
                                                        Get your key from <a href="https://openrouter.ai/keys" target="_blank" className="text-indigo-400 hover:underline">OpenRouter.ai</a>.
                                                    </p>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </main>
                        {/* TOAST NOTIFICATION */}
                        {toast && (
                            <div className={`fixed bottom-6 right-6 z-50 px-6 py-4 rounded-xl shadow-2xl border flex items-center gap-3 animate-fade-in ${toast.type === 'error' ? 'bg-red-900/90 border-red-500 text-red-100' : 'bg-emerald-900/90 border-emerald-500 text-emerald-100'}`}>
                                {toast.type === 'error' ? <X size={20} /> : <Sparkles size={20} />}
                                <div>
                                    <h4 className="font-bold text-sm">{toast.type === 'error' ? 'Error' : 'Success'}</h4>
                                    <p className="text-xs opacity-90">{toast.message}</p>
                                </div>
                            </div>
                        )}
                    </div >
                </div >
            );
        }

        const container = document.getElementById('root');
        if (!window.reactRoot) {
            window.reactRoot = ReactDOM.createRoot(container);
        }
        window.reactRoot.render(<EllipsisProsef />);
    </script>
</body>

</html>
